<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CH2MI LOG</title>
    <link>https://ch2mi.github.io/</link>
    
    <atom:link href="https://ch2mi.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 16 May 2025 15:17:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[백준] 20160 야쿠르트 아줌마 야쿠르트 주세요 (C++)</title>
      <link>https://ch2mi.github.io/2025/05/16/20160/</link>
      <guid>https://ch2mi.github.io/2025/05/16/20160/</guid>
      <pubDate>Fri, 16 May 2025 03:11:03 GMT</pubDate>
      
      <description>&lt;p&gt;문제 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yMDE2MA==&quot;&gt;https://www.acmicpc.net/problem/20160&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>문제 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yMDE2MA==">https://www.acmicpc.net/problem/20160<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>문제를 보면 최단 시간에 대한 이야기가 나오는데 여러 지점간 최단 시간을 구해야 되는 문제라 생각해서 제일 먼저 플로이드-워셜 알고리즘을 떠올렸다. 모든 지점 간의 최단 거리를 미리 구해놓으면 야구르트 아줌마가 지점별 도달 시간을 쉽게 구할 수 있고 내가 해당 시간 안에 도착할 수 있는지도 빠르게 구할 수 있다.</p><p>하지만 문제의 제약 조건을 확인하면 정점 $V$의 조건이 $(1 \leq V \leq 10000)$ 이므로 시간 복잡도가 $O(N^3)$인 플로이드-워셜을 쓰기에는 부적절하다는 것을 할 수 있다.</p><p>최단 거리를 구해야하는 횟수는</p><ol><li>야쿠르트 아줌마가 지점을 총 10군데 방문하므로 9번</li><li>내가 각 지점까지 가야하는 횟수 10번</li></ol><p>이므로 최대 19번 구하면 된다. </p><p>그러므로 다익스트라 알고리즘을 이용하면 충분하다.</p><p>다익스트라 함수는 출발지, 도착지를 넣으면 거리를 반환하는 형태로 구성하였다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF = LLONG_MAX;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> V, E;</span><br><span class="line">vector&lt;vector&lt;array&lt;ll, 2&gt;&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(V, INF)</span></span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;array&lt;ll, 2&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_dist, cur_node] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        cur_dist = -cur_dist;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_dist != dist[cur_node]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [nxt_node, nxt_dist] : adj[cur_node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_dist + nxt_dist &lt; dist[nxt_node]) &#123;</span><br><span class="line">                dist[nxt_node] = cur_dist + nxt_dist;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;-(cur_dist + nxt_dist), nxt_node&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[e];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>야구르트 아줌마의 각 지점별 도착 시간은 다음과 같이 구했다.</p><p><code>vector&lt;int&gt; v</code> : 지점 별 노드 번호</p><p><code>vector&lt;ll&gt; d</code> : 지점 별 도착 시간</p><p><code>cur</code> : 현재 야구르트 아줌마의 위치 (시작은 0)</p><p>로 하고 1부터 9번째 지점까지 돌면서 <code>v[cur]</code>에서 <code>v[i]</code>로 이동할 수 없으면 <code>d[i]</code>를 -1로 바꾸고, </p><p>이동할 수 있으면 <code>d[i]</code>는 현재 노드에 도착한 시간인 <code>d[cur]</code>에 <code>dist</code>를 더해주고 <code>cur</code>를 <code>i</code>로 바꿔 이동해주었다. 이 때 오버플로우가 발생할 수 있어 <code>long long</code> 형식으로 저장해주어야 한다.  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>&amp; i : v) cin &gt;&gt; i;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ll dist = <span class="built_in">Dijkstra</span>(v[cur] - <span class="number">1</span>, v[i] - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// v[cur] -&gt; v[i]로 이동할 수 없을 때</span></span><br><span class="line">    <span class="keyword">if</span> (dist == INF) &#123;</span><br><span class="line">        d[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// v[cur] -&gt; v[i]로 이동할 수 있으므로 v[i]로 이동한다.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        d[i] = d[cur] + dist;</span><br><span class="line">        cur = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>각 지점별로 야쿠르트 아줌마의 도착 시간을 구했다면 내 위치로부터 각 지점까지 최단 시간을 구하고 해당 지점에 갈 수 있고, 야구르트 아줌마와 같은 시간 혹은 이전 시간에 도착했다면 <code>ans</code> 벡터에 넣어주었다.</p><p>이후 <code>ans</code>를 정렬하여 번호가 가장 작은 정점을 출력하면 답을 얻을 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> me; cin &gt;&gt; me;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 야쿠르트 아줌마가 가지 않는 곳은 무시</span></span><br><span class="line">    <span class="keyword">if</span> (d[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 야쿠르트 아줌마보다 일찍 갈 수 있는지 확인한다.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Dijkstra</span>(me - <span class="number">1</span>, v[i] - <span class="number">1</span>) &lt;= d[i]) ans.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; ans.<span class="built_in">front</span>();</span><br></pre></td></tr></table></figure><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF = LLONG_MAX;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> V, E;</span><br><span class="line">vector&lt;vector&lt;array&lt;ll, 2&gt;&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(V, INF)</span></span>;</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;array&lt;ll, 2&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_dist, cur_node] = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        cur_dist = -cur_dist;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_dist != dist[cur_node]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [nxt_node, nxt_dist] : adj[cur_node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_dist + nxt_dist &lt; dist[nxt_node]) &#123;</span><br><span class="line">                dist[nxt_node] = cur_dist + nxt_dist;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;-(cur_dist + nxt_dist), nxt_node&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist[e];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; V &gt;&gt; E;</span><br><span class="line">    adj.<span class="built_in">assign</span>(V, vector&lt;array&lt;ll, <span class="number">2</span>&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        ll s, e, w; cin &gt;&gt; s &gt;&gt; e &gt;&gt; w;</span><br><span class="line">        adj[s - <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;e - <span class="number">1</span>, w&#125;);</span><br><span class="line">        adj[e - <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;s - <span class="number">1</span>, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">d</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; i : v) cin &gt;&gt; i;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ll dist = <span class="built_in">Dijkstra</span>(v[cur] - <span class="number">1</span>, v[i] - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (dist == INF) &#123;</span><br><span class="line">            d[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d[i] = d[cur] + dist;</span><br><span class="line">            cur = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> me; cin &gt;&gt; me;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Dijkstra</span>(me - <span class="number">1</span>, v[i] - <span class="number">1</span>) &lt;= d[i]) ans.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/../image/20160/img.png" alt="img.png"></p><p>최단 거리는 int 범위 내에서 구해져서 오버플로우를 생각하지 않았는데 야쿠르트 아줌마가 이동하면서 최단 거리가 누적될 때 오버플로우가 일어난다는 것을 생각하지 못해 틀렸다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Graph-Theory/">Graph Theory</category>
      
      <category domain="https://ch2mi.github.io/tags/Shortest-Path/">Shortest Path</category>
      
      <category domain="https://ch2mi.github.io/tags/Dijkstra-s/">Dijkstra&#39;s</category>
      
      
      <comments>https://ch2mi.github.io/2025/05/16/20160/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 5635 생일 (C++)</title>
      <link>https://ch2mi.github.io/2025/04/25/5635/</link>
      <guid>https://ch2mi.github.io/2025/04/25/5635/</guid>
      <pubDate>Fri, 25 Apr 2025 07:33:59 GMT</pubDate>
      
      <description>&lt;p&gt;문제 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS81NjM1&quot;&gt;https://www.acmicpc.net/problem/5635&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>문제 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS81NjM1">https://www.acmicpc.net/problem/5635<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p><code>이름 dd mm yyyy</code> 형식으로 입력이 주어졌을 때 가장 나이가 적은 사람과 가장 나이가 많은 사람을 찾으면 되는 문제이다.</p><p>생일이 같거나, 이름이 같은 사람은 없으므로 단순하게 연도, 월, 일 순으로 정렬하면 된다.</p><p>간편하게 정렬하기 위해 <code>tuple</code> STL을 이용했다. <code>tuple</code>은 정렬을 할 때 제일 앞에 원소부터 정렬이 되기 때문에 <code>tuple&lt;int, int, int, string&gt;</code> 형식으로 선언하고 연도, 월, 일, 이름 순으로 저장해주었다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, string&gt;&gt; <span class="built_in">v</span>(N);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    string s; <span class="type">int</span> d, m, y;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; d &gt;&gt; m &gt;&gt; y;</span><br><span class="line">    v[i] = &#123;y, m, d, s&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후 정렬을 하고 맨 뒤의 원소의 이름과 맨 앞의 원소의 이름을 출력하면 된다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line">    vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, string&gt;&gt; <span class="built_in">v</span>(N);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        string s; <span class="type">int</span> d, m, y;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; d &gt;&gt; m &gt;&gt; y;</span><br><span class="line">        v[i] = &#123;y, m, d, s&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(v.<span class="built_in">back</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(v.<span class="built_in">front</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/../image/5635/img.png" alt="img.png"></p><p><code>tuple</code>을 사용하면 구조체를 정의하고, 연산자를 따로 오버로딩 할 필요 없어 간단한 문제였다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Sorting/">Sorting</category>
      
      <category domain="https://ch2mi.github.io/tags/Implementation/">Implementation</category>
      
      <category domain="https://ch2mi.github.io/tags/String/">String</category>
      
      
      <comments>https://ch2mi.github.io/2025/04/25/5635/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 17611 직각다각형 (C++)</title>
      <link>https://ch2mi.github.io/2025/04/23/17611/</link>
      <guid>https://ch2mi.github.io/2025/04/23/17611/</guid>
      <pubDate>Wed, 23 Apr 2025 03:39:08 GMT</pubDate>
      
      <description>&lt;p&gt;문제 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xNzYxMQ==&quot;&gt;https://www.acmicpc.net/problem/17611&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>문제 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xNzYxMQ==">https://www.acmicpc.net/problem/17611<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>입력으로 주어진 단순직각다각형과 가장 많이 교차하는 수평선분 혹은 수직선분을 찾아야 하는 문제이다.</p><p>주어진 좌표의 범위가 $-500,000 ≤ x_i, y_i ≤ 500,000$ 이기 때문에<br>제일 먼저 든 생각은 x, y좌표를 전부 확인하면서 현재 몇 개가 겹쳐있는지 확인해도 될 것 같다는 생각이었다.</p><p>이를 바탕으로 조금만 더 최적화를 해보면 현재 몇 개의 선분이 겹쳐있는지 들고 있으면서 선분의 시작점, 끝점을 훑어보면 된다.</p><p>수평선, 수직선 각각의 경우에 대해 확인해야 하므로 들어온 입력으로 수평선과 수직선을 찾아내는 작업이 필요했다.</p><p>꼭짓점이 시계 방향으로 들어오므로 이전 점과 비교해서 x좌표가 같으면 수직선으로, y좌표가 같으면 수평선으로 넣어주었다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;point&gt; <span class="title">v</span><span class="params">(N)</span></span>; <span class="comment">// typedef array&lt;int, 2&gt; point;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : v) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">vector&lt;point&gt; h, w;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이전 점과 현재 점을 비교하기 위해 1 ~ N까지 돌면서 </span></span><br><span class="line"><span class="comment">// 이때 N일 때는 인덱스를 벗어나므로 현재 점은 % N을 통해 보정해주었다.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123; </span><br><span class="line">    <span class="keyword">if</span> (v[i - <span class="number">1</span>][<span class="number">0</span>] == v[i % N][<span class="number">0</span>]) &#123; <span class="comment">// x좌표가 같으므로 수직선</span></span><br><span class="line">        h.<span class="built_in">push_back</span>(&#123;v[i - <span class="number">1</span>][<span class="number">1</span>], v[i % N][<span class="number">1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 그외에는 수평선이다.</span></span><br><span class="line">        w.<span class="built_in">push_back</span>(&#123;v[i - <span class="number">1</span>][<span class="number">0</span>], v[i % N][<span class="number">0</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후 함수에서 수직선, 수평선 각각에 대해 최대 교차 횟수를 구해주어야 한다.</p><p>가장 작은 좌표부터 시작해서 시작점과 만나면 +1, 끝점과 만나면 -1을 해주면서 이때의 최댓값을 구하면 최대 교차 횟수를 구할 수 있다.</p><p>이를 위해 각 선분의 모든 점을 <code>&#123;점, 선분 번호&#125;</code> 형식으로 분리하고 배열에 넣어 정렬했다. </p><p>배열을 순회하면서 선분 번호가 처음 나오면 +1, 다시 나오면 -1을 해주는 방식으로 구현을 할 수 있다.</p><p>이때 주의해야할 점이 몇가지 있는데 먼저 현재 구현대로는 선분의 값이 모두 <code>시작점 &lt; 끝점</code>의 형식으로 되어 있지 않다는 것이다.</p><p>시계방향으로 점이 들어왔으므로 <code>끝점 &lt; 시작점</code>인 경우가 있기 때문에 이를 확인해 먼저 <code>swap</code>을 해주어야 한다.</p><p>두번째로 선분이 시작하거나, 끝나는 곳이 겹칠 때 조심해야 한다. 시작하는 곳을 먼저 계산하게 되면 해당 지점에서는 변화가 없어야 하는데 하나 커진 값이 최댓값으로 들어갈 수 있기 때문이다.</p><p>따라서 각 점에서 계산할 때에는 선분이 끝나는 것을 먼저 계산해야 한다. 이를 위해 배열에 넣을 때 시작점은 <code>&#123;시작점, 선분 번호&#125;</code>, 끝점은 <code>&#123;끝점, -선분 번호&#125;</code> 형태로 넣어주었다.</p><p><code>array</code>는 정렬할 때 인덱스 작은 값이 같으면 그 다음 인덱스를 기준으로 오름차순 정렬해주기 때문에 무조건 끝점을 먼저 계산할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;point&gt; <span class="title">v</span><span class="params">(h.size() * <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (h[i][<span class="number">0</span>] &gt; h[i][<span class="number">1</span>]) <span class="built_in">swap</span>(h[i][<span class="number">0</span>], h[i][<span class="number">1</span>]); <span class="comment">// 끝점 &lt; 시작점이면 바꿔준다.</span></span><br><span class="line">    v[i * <span class="number">2</span>] = &#123;h[i][<span class="number">0</span>], i + <span class="number">1</span>&#125;; <span class="comment">// 시작점은 양수, i가 0부터 시작하므로 선분번호를 1부터 넣어주었다.</span></span><br><span class="line">    v[i * <span class="number">2</span> + <span class="number">1</span>] = &#123;h[i][<span class="number">1</span>], -(i + <span class="number">1</span>)&#125;; <span class="comment">// 끝점은 음수</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>정렬을 완료했으면 v 벡터를 순회하면서 n이 음수일 때는 끝점이므로 교차 횟수를 -1, n이 양수일 때는 시작점이므로 교차 횟수를 +1하고, 최댓값을 계속해서 갱신하면 최대 교차 횟수를 구할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> [p, n] : v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123; <span class="comment">// 끝점이면 교차 횟수를 감소</span></span><br><span class="line">        --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 시작점이면 교차 횟수 증가 및 최댓값 갱신</span></span><br><span class="line">        mx = <span class="built_in">max</span>(mx, ++cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> array&lt;<span class="type">int</span>, 2&gt; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(vector&lt;point&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">v</span><span class="params">(h.size() * <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; h.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h[i][<span class="number">0</span>] &gt; h[i][<span class="number">1</span>]) <span class="built_in">swap</span>(h[i][<span class="number">0</span>], h[i][<span class="number">1</span>]);</span><br><span class="line">        v[i * <span class="number">2</span>] = &#123;h[i][<span class="number">0</span>], i + <span class="number">1</span>&#125;;</span><br><span class="line">        v[i * <span class="number">2</span> + <span class="number">1</span>] = &#123;h[i][<span class="number">1</span>], -(i + <span class="number">1</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [p, n] : v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, ++cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">v</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : v) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    vector&lt;point&gt; h, w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i - <span class="number">1</span>][<span class="number">0</span>] == v[i % N][<span class="number">0</span>]) &#123;</span><br><span class="line">            h.<span class="built_in">push_back</span>(&#123;v[i - <span class="number">1</span>][<span class="number">1</span>], v[i % N][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            w.<span class="built_in">push_back</span>(&#123;v[i - <span class="number">1</span>][<span class="number">0</span>], v[i % N][<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(<span class="built_in">cal</span>(h), <span class="built_in">cal</span>(w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/../image/17611/img.png" alt="img.png"><br>처음 문제를 풀 때 <code>시작점 &gt; 끝점</code> 이 경우를 고려하지 않아 틀렸다.<br>디버깅하면서 해당 경우를 찾아내어 swap 하는 걸로 바꿔주었다.</p><p>또한 imos 누적합으로 풀 수 있는데 imos의 개념만 알고 실제로 해당 알고리즘을 사용한 적이 없어 해당 방법은 잘 떠오르지 않았다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Sorting/">Sorting</category>
      
      <category domain="https://ch2mi.github.io/tags/Prefix-Sum/">Prefix Sum</category>
      
      <category domain="https://ch2mi.github.io/tags/Sweeping/">Sweeping</category>
      
      
      <comments>https://ch2mi.github.io/2025/04/23/17611/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 13911 집 구하기 (C++)</title>
      <link>https://ch2mi.github.io/2025/01/08/13911/</link>
      <guid>https://ch2mi.github.io/2025/01/08/13911/</guid>
      <pubDate>Wed, 08 Jan 2025 14:03:47 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMzkxMQ==&quot;&gt;https://www.acmicpc.net/problem/13911&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;안양에 사는 상혁이는 4년간의 통학에 지쳐 서울에 집을 구하려고 한다. 상혁이가 원하는 집은 세가지 조건이 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;맥세권 : 맥세권인 집은 맥도날드와 집 사이의 최단거리가 x이하인 집이다.&lt;/li&gt;
&lt;li&gt;스세권 : 스세권인 집은 스타벅스와 집 사이의 최단거리가 y이하인 집이다.&lt;/li&gt;
&lt;li&gt;맥세권과 스세권을 만족하는 집 중 최단거리의 합이 최소인 집&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;통학 때문에 스트레스를 많이 받은 상혁이는 집을 선택하는 데 어려움을 겪고 있다. 똑똑한 여러분이 상혁이 대신 이 문제를 해결해 주자. 이사 갈 지역의 지도가 그래프로 주어지고 맥도날드와 스타벅스의 위치가 정점 번호로 주어질 때 상혁이가 원하는 집의 최단거리의 합을 출력하는 프로그램을 작성하시오. (맥도날드와 스타벅스가 아닌 정점에는 모두 집이 있다.)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/13911/img.png&quot; alt=&quot;img.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;위의 예제 지도에서 사각형은 맥도날드를, 별은 스타벅스가 위치한 정점을 나타낸다. 각 원은 집이 있는 정점을 낸다. x가 6이고 y가 4일 때 가능한 집의 정점은 6이다. 맥도날드까지의 최단거리가 2, 스타벅스까지의 최단거리가 4로 총 합이 6이 되기 때문이다. 정점 7은 맥세권이면서 스세권이지만 맥도날드까지의 최단거리가 6, 스타벅스까지의 최단거리가 2로 총 합이 8로써 정점 6의 값보다 크므로 답이 아니다. 그 외의 정점 2, 3, 4는 맥세권이면서 스세권인 조건을 충족하지 못하므로 답이 될 수 없다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xMzkxMQ==">https://www.acmicpc.net/problem/13911<i class="fa fa-external-link-alt"></i></span></p><p>안양에 사는 상혁이는 4년간의 통학에 지쳐 서울에 집을 구하려고 한다. 상혁이가 원하는 집은 세가지 조건이 있다.</p><ul><li>맥세권 : 맥세권인 집은 맥도날드와 집 사이의 최단거리가 x이하인 집이다.</li><li>스세권 : 스세권인 집은 스타벅스와 집 사이의 최단거리가 y이하인 집이다.</li><li>맥세권과 스세권을 만족하는 집 중 최단거리의 합이 최소인 집</li></ul><p>통학 때문에 스트레스를 많이 받은 상혁이는 집을 선택하는 데 어려움을 겪고 있다. 똑똑한 여러분이 상혁이 대신 이 문제를 해결해 주자. 이사 갈 지역의 지도가 그래프로 주어지고 맥도날드와 스타벅스의 위치가 정점 번호로 주어질 때 상혁이가 원하는 집의 최단거리의 합을 출력하는 프로그램을 작성하시오. (맥도날드와 스타벅스가 아닌 정점에는 모두 집이 있다.)</p><p><img src="/image/13911/img.png" alt="img.png"></p><p>위의 예제 지도에서 사각형은 맥도날드를, 별은 스타벅스가 위치한 정점을 나타낸다. 각 원은 집이 있는 정점을 낸다. x가 6이고 y가 4일 때 가능한 집의 정점은 6이다. 맥도날드까지의 최단거리가 2, 스타벅스까지의 최단거리가 4로 총 합이 6이 되기 때문이다. 정점 7은 맥세권이면서 스세권이지만 맥도날드까지의 최단거리가 6, 스타벅스까지의 최단거리가 2로 총 합이 8로써 정점 6의 값보다 크므로 답이 아니다. 그 외의 정점 2, 3, 4는 맥세권이면서 스세권인 조건을 충족하지 못하므로 답이 될 수 없다.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>일반적인 다익스트라 알고리즘은 시작 정점을 하나로 설정하고 해당 정점에서 다른 정점들까지의 최단거리를 구한다.</p><p>이를 변형해서 시작 정점을 여러 개로 설정해서 다익스트라 알고리즘을 돌리면 시작 정점 쌍에서 다른 정점들까지의 최단거리를 구할 수 있다.</p><p>즉 맥도날드 정점들을 시작정점으로 한 번, 스타벅스 정점들을 시작정점으로 한 번 다익스트라 알고리즘을 돌리면 각 집에서 가장 가까운 맥도날드와 스타벅스를 구할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> M, x, S, y;</span><br><span class="line">cin &gt;&gt; M &gt;&gt; x;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m</span><span class="params">(V)</span></span>; <span class="comment">// 맥도날드 정점</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a; cin &gt;&gt; a; m[a - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; S &gt;&gt; y;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(V)</span></span>; <span class="comment">// 스타벅스 정점</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">    <span class="type">int</span> a; cin &gt;&gt; a; s[a - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 위해 맥도날드나 스타벅스 정점의 경우 해당 배열의 값을 1로 설정해주고 다익스트라 함수의 인자로 넘겨주었다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">Dijkstra</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;ll, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(V, INF)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 시작 정점을 모두 우선순위 큐에 넣어준다.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">        <span class="keyword">if</span> (v[i]) </span><br><span class="line">            pq.<span class="built_in">emplace</span>(<span class="number">0</span>, i), dist[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_dist, cur_node] = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        cur_dist = -cur_dist;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[cur_node] != cur_dist) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt_node, d] : adj[cur_node]) &#123;</span><br><span class="line">            ll nxt_dist = cur_dist + d;</span><br><span class="line">            <span class="keyword">if</span> (nxt_dist &lt; dist[nxt_node]) &#123;</span><br><span class="line">                dist[nxt_node] = nxt_dist;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(-nxt_dist, nxt_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후 다익스트라 함수에서 전달받은 배열 중 1인 정점들은 모두 시작정점으로 하여 다익스트라를 돌린 뒤 거리 배열을 반환해주면 각 집에서 맥도날드와 스타벅스까지의 거리를 각각 구할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ll mn = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) </span><br><span class="line">    <span class="keyword">if</span> (!m[i] &amp;&amp; !s[i] &amp;&amp; md[i] &lt;= x &amp;&amp; sd[i] &lt;= y) </span><br><span class="line">        mn = <span class="built_in">min</span>(mn, md[i] + sd[i]);</span><br></pre></td></tr></table></figure><p>이후 맥도날드, 스타벅스가 아니면서 맥세권과 스세권인 집이면 최솟값을 갱신해 주었다.</p><p>이후 mn의 값이 INF 이면 -1을, 아니면 mn을 출력하면 된다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">constexpr</span> ll INF = LLONG_MAX;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> V;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, ll&gt;&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">Dijkstra</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;pair&lt;ll, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(V, INF)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) <span class="keyword">if</span> (v[i]) pq.<span class="built_in">emplace</span>(<span class="number">0</span>, i), dist[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_dist, cur_node] = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        cur_dist = -cur_dist;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dist[cur_node] != cur_dist) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt_node, d] : adj[cur_node]) &#123;</span><br><span class="line">            ll nxt_dist = cur_dist + d;</span><br><span class="line">            <span class="keyword">if</span> (nxt_dist &lt; dist[nxt_node]) &#123;</span><br><span class="line">                dist[nxt_node] = nxt_dist;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(-nxt_dist, nxt_node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> E; cin &gt;&gt; V &gt;&gt; E;</span><br><span class="line">    adj.<span class="built_in">assign</span>(V, vector&lt;pair&lt;<span class="type">int</span>, ll&gt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s, e; ll w;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; e &gt;&gt; w;</span><br><span class="line">        adj[s - <span class="number">1</span>].<span class="built_in">emplace_back</span>(e - <span class="number">1</span>, w);</span><br><span class="line">        adj[e - <span class="number">1</span>].<span class="built_in">emplace_back</span>(s - <span class="number">1</span>, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> M, x, S, y;</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; x;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">m</span><span class="params">(V)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a; cin &gt;&gt; a; m[a - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; S &gt;&gt; y;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(V)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a; cin &gt;&gt; a; s[a - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt; md = <span class="built_in">Dijkstra</span>(m), sd = <span class="built_in">Dijkstra</span>(s);</span><br><span class="line"></span><br><span class="line">    ll mn = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++) <span class="keyword">if</span> (!m[i] &amp;&amp; !s[i] &amp;&amp; md[i] &lt;= x &amp;&amp; sd[i] &lt;= y) mn = <span class="built_in">min</span>(mn, md[i] + sd[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mn == INF) cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; mn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/13911/img_1.png" alt="img.png"></p><p>시작 정점이 여러 개로 설정하고 다익스트라를 하는 아이디어가 참신한 문제였다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Graph-Theory/">Graph Theory</category>
      
      <category domain="https://ch2mi.github.io/tags/Shortest-Path/">Shortest Path</category>
      
      <category domain="https://ch2mi.github.io/tags/Dijkstra-s/">Dijkstra&#39;s</category>
      
      
      <comments>https://ch2mi.github.io/2025/01/08/13911/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 24235 유산 (C++)</title>
      <link>https://ch2mi.github.io/2024/12/25/24235/</link>
      <guid>https://ch2mi.github.io/2024/12/25/24235/</guid>
      <pubDate>Wed, 25 Dec 2024 10:37:32 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yNDIzNQ==&quot;&gt;https://www.acmicpc.net/problem/24235&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;조상때부터 대대로 물려받던 땅이 있다. 땅이 매우 크기 때문에&lt;br&gt;$N$개 위치를 좌표평면 위에 점으로 표시를 해놓았다. 땅은&lt;br&gt;$N$개의 점을 모두 포함하는 가장 작은 볼록다각형이다.&lt;/p&gt;
&lt;p&gt;이 땅을 두 명한테 나눠주려고 한다. 나눠주는 땅의 넓이가 같도록 해야 싸움이 일어나지 않을 것이기 때문에&lt;br&gt;$y$축이랑 평행한 직선 $x &amp;#x3D; a$를 그어 나눠지는 두 땅의 넓이가 같도록 하려고 한다.&lt;/p&gt;
&lt;p&gt;[그림 1]처럼 좌표평면에 9개 점이 존재한다고 가정해보자.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/24235/img.png&quot; alt=&quot;img.png&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;

&lt;p&gt;[그림 1] 9개의 점을 좌표평면에 표시&lt;/p&gt;
&lt;/div&gt;  

&lt;p&gt;땅을 표시하는 좌표평면 정보에서 땅은 9개의 점을 모두 포함하는 가장 작은 볼록다각형이기 때문에 [그림 2]와 같다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/24235/img_1.png&quot; alt=&quot;img_1.png&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt;

&lt;p&gt;[그림 2] 좌표평면에 땅에 해당하는 부분 표시&lt;/p&gt;
&lt;/div&gt;  

&lt;p&gt;두 명이 이 땅을 넓이가 같도록 나눠야 하기 때문에 [그림 3]처럼 직선을 그어 두 땅의 넓이가 같도록 구분하면 된다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/24235/img_2.png&quot; alt=&quot;img_2.png&quot;&gt;&lt;/p&gt;
&lt;div style=&quot;text-align: center;&quot;&gt; 

&lt;p&gt;[그림 3] 두 땅의 넓이가 같도록 $x &amp;#x3D; a$ 직선으로 구분 &lt;/p&gt;
&lt;/div&gt;  

&lt;p&gt;땅의 정보가 주어졌을 때 같은 면적의 땅을 나눌 수 있도록 $a$의 값을 찾아주자.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yNDIzNQ==">https://www.acmicpc.net/problem/24235<i class="fa fa-external-link-alt"></i></span></p><p>조상때부터 대대로 물려받던 땅이 있다. 땅이 매우 크기 때문에<br>$N$개 위치를 좌표평면 위에 점으로 표시를 해놓았다. 땅은<br>$N$개의 점을 모두 포함하는 가장 작은 볼록다각형이다.</p><p>이 땅을 두 명한테 나눠주려고 한다. 나눠주는 땅의 넓이가 같도록 해야 싸움이 일어나지 않을 것이기 때문에<br>$y$축이랑 평행한 직선 $x &#x3D; a$를 그어 나눠지는 두 땅의 넓이가 같도록 하려고 한다.</p><p>[그림 1]처럼 좌표평면에 9개 점이 존재한다고 가정해보자.</p><p><img src="/image/24235/img.png" alt="img.png"></p><div style="text-align: center;"><p>[그림 1] 9개의 점을 좌표평면에 표시</p></div>  <p>땅을 표시하는 좌표평면 정보에서 땅은 9개의 점을 모두 포함하는 가장 작은 볼록다각형이기 때문에 [그림 2]와 같다.</p><p><img src="/image/24235/img_1.png" alt="img_1.png"></p><div style="text-align: center;"><p>[그림 2] 좌표평면에 땅에 해당하는 부분 표시</p></div>  <p>두 명이 이 땅을 넓이가 같도록 나눠야 하기 때문에 [그림 3]처럼 직선을 그어 두 땅의 넓이가 같도록 구분하면 된다.</p><p><img src="/image/24235/img_2.png" alt="img_2.png"></p><div style="text-align: center;"> <p>[그림 3] 두 땅의 넓이가 같도록 $x &#x3D; a$ 직선으로 구분 </p></div>  <p>땅의 정보가 주어졌을 때 같은 면적의 땅을 나눌 수 있도록 $a$의 값을 찾아주자.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>문제에 대한 접근은 어렵지 않다.</p><p>주어진 땅의 넓이가 $N$개의 점을 모두 포함하는 가장 작은 볼록다각형이라고 주어졌으니 주어진 점으로 컨벡스 헐을 만든다.</p><p>땅을 나눌 때는 $y$축과 평행한 직선으로 땅을 나누면 되기 때문에 컨벡스 헐에서 $x_{min}$과 $x_{max}$를 구한 뒤, 이를 lo, hi로 놓고 이분 탐색을 돌리면 된다.</p><p>이때 땅의 넓이는 부동 소수점으로 표현되기 때문에 오차에 유의하여 돌아야 한다.</p><h4 id="컨벡스헐-구하기"><a href="#컨벡스헐-구하기" class="headerlink" title="컨벡스헐 구하기"></a>컨벡스헐 구하기</h4><p>컨벡스 헐을 구하는 부분은 <a href="https://ch2mi.github.io/2024/11/24/3878/#%EC%BD%94%EB%93%9C">3878 점분리</a>에 사용한 코드를 살짝 변형했다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(point&amp; a, point&amp; b, point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">0</span>] * b[<span class="number">1</span>] + b[<span class="number">0</span>] * c[<span class="number">1</span>] + c[<span class="number">0</span>] * a[<span class="number">1</span>] - (b[<span class="number">0</span>] * a[<span class="number">1</span>] + c[<span class="number">0</span>] * b[<span class="number">1</span>] + a[<span class="number">0</span>] * c[<span class="number">1</span>])) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCW</span><span class="params">(point&amp; a, point&amp; b, point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="built_in">area</span>(a, b, c);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(point&amp; a, point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = b[<span class="number">0</span>] - a[<span class="number">0</span>], dy = b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dx * dx + dy * dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;point&gt; <span class="title">convexhull</span><span class="params">(vector&lt;point&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), [&amp;](point&amp; a, point&amp; b) &#123;</span><br><span class="line">        <span class="type">int</span> ccw = <span class="built_in">CCW</span>(v[<span class="number">0</span>], a, b);</span><br><span class="line">        <span class="keyword">if</span> (!ccw) <span class="keyword">return</span> <span class="built_in">dist</span>(v[<span class="number">0</span>], a) &lt; <span class="built_in">dist</span>(v[<span class="number">0</span>], b);</span><br><span class="line">        <span class="keyword">return</span> ccw &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>)v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = st.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CCW</span>(v[b], v[a], v[i]) &gt; <span class="number">0</span>) st.<span class="built_in">push</span>(a), st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span> i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">ch</span><span class="params">(st.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ch) p = v[st.<span class="built_in">top</span>()], st.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이후 넓이를 구하는 부분이 필요하기 때문에 외적하는 부분을 <code>area()</code>로 따로 분리한 것 이외는 차이가 없다.</p><h4 id="윗껍질-아랫껍질-분리하기"><a href="#윗껍질-아랫껍질-분리하기" class="headerlink" title="윗껍질, 아랫껍질 분리하기"></a>윗껍질, 아랫껍질 분리하기</h4><p>컨벅스 헐을 구했으면 넓이를 계산하기 위해 윗 껍질과 아래껍질로 분리했다.</p><p>컨벡스 헐을 구하는 알고리즘 중에 모노톤 체인 기법을 이용하면 편리하게 분리할 수 있겠지만 그라함 스캔이 익숙해서 컨벡스 헐을 구한 뒤 이를 분리했다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sep</span><span class="params">(vector&lt;point&gt;&amp; ch, vector&lt;point&gt;&amp; up, vector&lt;point&gt;&amp; down)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = (<span class="type">int</span>)ch.<span class="built_in">size</span>();</span><br><span class="line">    up.<span class="built_in">push_back</span>(ch[l - <span class="number">1</span>]); down.<span class="built_in">push_back</span>(ch[l - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch[i][<span class="number">0</span>] &lt;= ch[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">        up.<span class="built_in">push_back</span>(ch[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    up.<span class="built_in">push_back</span>(ch[i]);</span><br><span class="line">    <span class="type">int</span> j = l - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        down.<span class="built_in">push_back</span>(ch[j--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>내가 사용하는 컨벡스 헐은 정점들이 시계방향으로 담겨있기 때문에 방향에 유의해서 up과 down 벡터에 $x$좌표가 증가하는 방향으로 좌표들이 저장될 수 있게 했다.</p><p>[예제 1]을 <code>sep()</code> 함수까지 실행하면 아래와 같이 윗껍질과 아래껍질이 분리되는 것을 볼 수 있다.</p><p><img src="/image/24235/img_3.png" alt="img_3.png"></p><h4 id="solve-함수-만들기-1-컨벡스-헐과-직선의-교점-구하기"><a href="#solve-함수-만들기-1-컨벡스-헐과-직선의-교점-구하기" class="headerlink" title="solve 함수 만들기 (1) - 컨벡스 헐과 직선의 교점 구하기"></a>solve 함수 만들기 (1) - 컨벡스 헐과 직선의 교점 구하기</h4><p>이분 탐색을 돌 때 조건을 어떻게 만족하는지에 따라 lo와 hi를 변경하는데 이를 판별하기위한 <code>solve()</code> 함수가 필요하다.</p><p><code>solve()</code> 함수에서는 $x&#x3D;mid$에서 왼쪽 구역과 오른쪽 구역을 나누고 이 두 구역의 넓이를 비교한다.</p><p>왼쪽 구역과 오른쪽 구역을 나누기 위해서는 컨벡스 헐과 $x&#x3D;mid$의 교점이 필요하다.</p><p>교점이 한 껍질의 두 점 $a(x_1, y_1), b(x_2, y_2)$을 잇는 선분에 생길 때 우리는 교점의 $x$좌표인 $mid$를 알고 있기 때문에 up과 down에서 $x$좌표에 대해 $mid$로 <code>lower_bound</code>를 사용한다면 $b$의 좌표를 구할 수 있다.</p><p>$a$점은 $b$점의 바로 이전 점이기 때문에 추가적으로 구할 필요가 없다.</p><p>컨벡스 헐은 각 점을 직선으로 연결하기 때문에 선형 보간을 이용해 선분과 직선의 교점$(x, y)$을 찾을 수 있다.</p><p>$$ x &#x3D; mid \quad y &#x3D; y_1 + t(y_2 - y_1) \quad t&#x3D;\frac {(mid - x_1)}{(x_2 - x_1)} $$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">point <span class="title">intersection</span><span class="params">(point&amp; a, point&amp; b, <span class="type">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> t = (c - a[<span class="number">0</span>]) / (b[<span class="number">0</span>] - a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> &#123;c, a[<span class="number">1</span>] + t * (b[<span class="number">1</span>] - a[<span class="number">1</span>])&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;point&gt;&amp; up, vector&lt;point&gt;&amp; down, <span class="type">double</span> mid)</span> </span>&#123;</span><br><span class="line">    point m = &#123;mid, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ui = <span class="built_in">lower_bound</span>(up.<span class="built_in">begin</span>(), up.<span class="built_in">end</span>(), m) - up.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> di = <span class="built_in">lower_bound</span>(down.<span class="built_in">begin</span>(), down.<span class="built_in">end</span>(), m) - down.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    point u = <span class="built_in">intersection</span>(up[ui - <span class="number">1</span>], up[ui], mid);</span><br><span class="line">    point d = <span class="built_in">intersection</span>(down[di - <span class="number">1</span>], down[di], mid);</span><br></pre></td></tr></table></figure><p><code>lower_bound</code>를 통해 윗껍질과 아랫껍질에서 교차하는 선분을 구하고, <code>intersection()</code> 함수에서 선분과 만나는 교점을 구해주었다.</p><h4 id="solve-함수-만들기-2-두-영역의-넓이-구하기"><a href="#solve-함수-만들기-2-두-영역의-넓이-구하기" class="headerlink" title="solve 함수 만들기 (2) - 두 영역의 넓이 구하기"></a>solve 함수 만들기 (2) - 두 영역의 넓이 구하기</h4><p>영역을 구할 때 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8yMTY2">2166 - 다각형의 면적<i class="fa fa-external-link-alt"></i></span> 문제처럼 다각형의 이루는 순서대로 배열에 담겨 있으면 쉽게 넓이를 구할 수 있다.</p><p>따라서 아래와 같이 시계 반대 방향 순서로 점들을 점들을 담아주었다.</p><p><img src="/image/24235/img_4.png" alt="img_4.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;point&gt; p1;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">reserve</span>(up.<span class="built_in">size</span>() + down.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; di; i++) p<span class="number">1.</span><span class="built_in">push_back</span>(down[i]);</span><br><span class="line">p<span class="number">1.</span><span class="built_in">push_back</span>(d);</span><br><span class="line">p<span class="number">1.</span><span class="built_in">push_back</span>(u);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ui - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) p<span class="number">1.</span><span class="built_in">push_back</span>(up[i]);</span><br><span class="line"></span><br><span class="line">vector&lt;point&gt; p2;</span><br><span class="line">p<span class="number">2.</span><span class="built_in">reserve</span>(up.<span class="built_in">size</span>() + down.<span class="built_in">size</span>());</span><br><span class="line">p<span class="number">2.</span><span class="built_in">push_back</span>(d);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = di; i &lt; down.<span class="built_in">size</span>(); i++) p<span class="number">2.</span><span class="built_in">push_back</span>(down[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = up.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= ui; i--) p<span class="number">2.</span><span class="built_in">push_back</span>(up[i]);</span><br><span class="line">p<span class="number">2.</span><span class="built_in">push_back</span>(u);</span><br></pre></td></tr></table></figure><p>만약 담는 과정에서 교점이 컨벡스 헐을 구성하는 점을 지나간다면 같은 점이 두 번 배열에 담길 수도 있지만, CCW를 계산할 때 0이 나와 상관이 없다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(vector&lt;point&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; (<span class="type">int</span>)a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += <span class="built_in">abs</span>(<span class="built_in">area</span>(a[<span class="number">0</span>], a[i - <span class="number">1</span>], a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;point&gt;&amp; up, vector&lt;point&gt;&amp; down, <span class="type">double</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생략</span></span><br><span class="line">    <span class="type">double</span> left = <span class="built_in">area</span>(p1), right = <span class="built_in">area</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>area()</code> 함수를 통해 p1배열과 p2 배열의 넓이를 각각 구해주고 왼쪽 부분과 오른쪽 부분 넓이를 비교한 결과를 반환했다.</p><h4 id="이분-탐색-만들기"><a href="#이분-탐색-만들기" class="headerlink" title="이분 탐색 만들기"></a>이분 탐색 만들기</h4><p>lo는 $x_{min}$, hi는 $x_{max}$로 설정하고 <code>(lo + 1e-5 &lt; hi)</code>를 만족할 때까지 이분 탐색을 반복했다.</p><p><code>solve()</code> 함수가 <code>true</code>면 왼쪽 구역의 넓이가 더 작으므로 <code>lo = mid</code>로 설정하고,</p><p><code>false</code>면 오른쪽 구역의 넓이가 더 작으므로 <code>hi = mid</code>로 설정했다.</p><p>반복이 끝났으면 lo, hi의 차이가 $10^{-5}$보다 작아 lo, hi중 둘 중 아무거나 출력해도 문제의 출력조건 절대&#x2F;상대 오차가 $10^{-3}$ 이하를 만족해서, lo를 출력했다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> lo = up[<span class="number">0</span>][<span class="number">0</span>], hi = up[up.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span> (lo<span class="number">+1e-5</span>&lt;hi) &#123;</span><br><span class="line">    <span class="type">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">solve</span>(up, down, mid)) lo = mid;</span><br><span class="line">    <span class="keyword">else</span> hi = mid;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fixed;</span><br><span class="line">cout.<span class="built_in">precision</span>(<span class="number">4</span>);</span><br><span class="line">cout &lt;&lt; lo;</span><br></pre></td></tr></table></figure><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> array&lt;<span class="type">double</span>, 2&gt; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(point&amp; a, point&amp; b, point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a[<span class="number">0</span>] * b[<span class="number">1</span>] + b[<span class="number">0</span>] * c[<span class="number">1</span>] + c[<span class="number">0</span>] * a[<span class="number">1</span>] - (b[<span class="number">0</span>] * a[<span class="number">1</span>] + c[<span class="number">0</span>] * b[<span class="number">1</span>] + a[<span class="number">0</span>] * c[<span class="number">1</span>])) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCW</span><span class="params">(point&amp; a, point&amp; b, point&amp; c)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> ans = <span class="built_in">area</span>(a, b, c);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(point&amp; a, point&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> dx = b[<span class="number">0</span>] - a[<span class="number">0</span>], dy = b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dx * dx + dy * dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;point&gt; <span class="title">convexhull</span><span class="params">(vector&lt;point&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), [&amp;](point&amp; a, point&amp; b) &#123;</span><br><span class="line">        <span class="type">int</span> ccw = <span class="built_in">CCW</span>(v[<span class="number">0</span>], a, b);</span><br><span class="line">        <span class="keyword">if</span> (!ccw) <span class="keyword">return</span> <span class="built_in">dist</span>(v[<span class="number">0</span>], a) &lt; <span class="built_in">dist</span>(v[<span class="number">0</span>], b);</span><br><span class="line">        <span class="keyword">return</span> ccw &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>)v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = st.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CCW</span>(v[b], v[a], v[i]) &gt; <span class="number">0</span>) st.<span class="built_in">push</span>(a), st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span> i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">ch</span><span class="params">(st.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ch) p = v[st.<span class="built_in">top</span>()], st.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sep</span><span class="params">(vector&lt;point&gt;&amp; ch, vector&lt;point&gt;&amp; up, vector&lt;point&gt;&amp; down)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = (<span class="type">int</span>)ch.<span class="built_in">size</span>();</span><br><span class="line">    up.<span class="built_in">push_back</span>(ch[l - <span class="number">1</span>]); down.<span class="built_in">push_back</span>(ch[l - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch[i][<span class="number">0</span>] &lt;= ch[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">        up.<span class="built_in">push_back</span>(ch[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    up.<span class="built_in">push_back</span>(ch[i]);</span><br><span class="line">    <span class="type">int</span> j = l - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        down.<span class="built_in">push_back</span>(ch[j--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">point <span class="title">intersection</span><span class="params">(point&amp; a, point&amp; b, <span class="type">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> t = (c - a[<span class="number">0</span>]) / (b[<span class="number">0</span>] - a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> &#123;c, a[<span class="number">1</span>] + t * (b[<span class="number">1</span>] - a[<span class="number">1</span>])&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(vector&lt;point&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; (<span class="type">int</span>)a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        sum += <span class="built_in">abs</span>(<span class="built_in">area</span>(a[<span class="number">0</span>], a[i - <span class="number">1</span>], a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;point&gt;&amp; up, vector&lt;point&gt;&amp; down, <span class="type">double</span> mid)</span> </span>&#123;</span><br><span class="line">    point m = &#123;mid, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> ui = <span class="built_in">lower_bound</span>(up.<span class="built_in">begin</span>(), up.<span class="built_in">end</span>(), m) - up.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="type">int</span> di = <span class="built_in">lower_bound</span>(down.<span class="built_in">begin</span>(), down.<span class="built_in">end</span>(), m) - down.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">    point u = <span class="built_in">intersection</span>(up[ui - <span class="number">1</span>], up[ui], mid);</span><br><span class="line">    point d = <span class="built_in">intersection</span>(down[di - <span class="number">1</span>], down[di], mid);</span><br><span class="line"></span><br><span class="line">    vector&lt;point&gt; p1;</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">reserve</span>(up.<span class="built_in">size</span>() + down.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; di; i++) p<span class="number">1.</span><span class="built_in">push_back</span>(down[i]);</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">push_back</span>(d);</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = ui - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) p<span class="number">1.</span><span class="built_in">push_back</span>(up[i]);</span><br><span class="line"></span><br><span class="line">    vector&lt;point&gt; p2;</span><br><span class="line">    p<span class="number">2.</span><span class="built_in">reserve</span>(up.<span class="built_in">size</span>() + down.<span class="built_in">size</span>());</span><br><span class="line">    p<span class="number">2.</span><span class="built_in">push_back</span>(d);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = di; i &lt; down.<span class="built_in">size</span>(); i++) p<span class="number">2.</span><span class="built_in">push_back</span>(down[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = up.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= ui; i--) p<span class="number">2.</span><span class="built_in">push_back</span>(up[i]);</span><br><span class="line">    p<span class="number">2.</span><span class="built_in">push_back</span>(u);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> left = <span class="built_in">area</span>(p1), right = <span class="built_in">area</span>(p2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">v</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : v) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">ch</span><span class="params">(convexhull(v))</span></span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;point&gt; up, down;</span><br><span class="line">    <span class="built_in">sep</span>(ch, up, down);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> lo = up[<span class="number">0</span>][<span class="number">0</span>], hi = up[up.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span> (lo<span class="number">+1e-5</span>&lt;hi) &#123;</span><br><span class="line">        <span class="type">double</span> mid = (lo + hi) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(up, down, mid)) lo = mid;</span><br><span class="line">        <span class="keyword">else</span> hi = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; lo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/24235/img_5.png" alt="img_5.png"></p><p>문제를 어떻게 풀어야하는지 아이디어는 쉽지만 구현이 복잡하고, 실수하기 쉬운 문제였다.</p><p>부동 소숫점으로 이분 탐색을 도는 경우가 처음이라 종료 조건을 잘못 세우는 바람에 3번 틀렸다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Geometry/">Geometry</category>
      
      <category domain="https://ch2mi.github.io/tags/Binary-Search/">Binary Search</category>
      
      <category domain="https://ch2mi.github.io/tags/Parametric-Search/">Parametric Search</category>
      
      <category domain="https://ch2mi.github.io/tags/Convex-Hull/">Convex Hull</category>
      
      <category domain="https://ch2mi.github.io/tags/Area-Of-A-Polygon/">Area Of A Polygon</category>
      
      
      <comments>https://ch2mi.github.io/2024/12/25/24235/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 32301 세계를 만들어요 (C++)</title>
      <link>https://ch2mi.github.io/2024/12/20/32301/</link>
      <guid>https://ch2mi.github.io/2024/12/20/32301/</guid>
      <pubDate>Fri, 20 Dec 2024 14:09:37 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8zMjMwMQ==&quot;&gt;https://www.acmicpc.net/problem/32301&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;호반우는 세계를 부수고, 세계를 창조한다.&lt;/p&gt;
&lt;p&gt;오늘도 호반우는 무방향 그래프로 이루어진 세계를 부숴버려 세계는 간선 없이 $1$번부터 $3N$번까지 번호가 매겨진 정점  $3N$개만 남게 되었다.&lt;/p&gt;
&lt;p&gt;호반우는 $3M$개의 간선을 만들어 세계를 다시 창조하려 하는데 각 정점에 연결된 간선의 개수가 소수이고 모든 정점이 연결되게 하려 한다. 임의의 두 정점이 이미 간선으로 연결되어 있다면 간선을 연결할 수 없으며 같은 정점 $2$개를 잇는 간선인 루프가 생기면 안 된다.&lt;/p&gt;
&lt;p&gt;호반우를 도와 세계를 만들어보자.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8zMjMwMQ==">https://www.acmicpc.net/problem/32301<i class="fa fa-external-link-alt"></i></span></p><p>호반우는 세계를 부수고, 세계를 창조한다.</p><p>오늘도 호반우는 무방향 그래프로 이루어진 세계를 부숴버려 세계는 간선 없이 $1$번부터 $3N$번까지 번호가 매겨진 정점  $3N$개만 남게 되었다.</p><p>호반우는 $3M$개의 간선을 만들어 세계를 다시 창조하려 하는데 각 정점에 연결된 간선의 개수가 소수이고 모든 정점이 연결되게 하려 한다. 임의의 두 정점이 이미 간선으로 연결되어 있다면 간선을 연결할 수 없으며 같은 정점 $2$개를 잇는 간선인 루프가 생기면 안 된다.</p><p>호반우를 도와 세계를 만들어보자.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>문제를 풀기 위해선 약간의 관찰이 필요하다.</p><p>우선 간선 하나가 두 정점을 이으므로 하나의 간선이 생길 때마다 각 정점에 연결된 간선의 총합은 2씩 증가한다.</p><p>또한 M의 범위가 $N \leq M \leq 2N$ 이다. </p><p>만약 $N &#x3D;&#x3D; 4$일 때 $M &#x3D;&#x3D; N$이라면 정점의 개수는 12개, 간선의 개수는 12개가 나온다.</p><p>각 정점에 연결된 간선의 총합은 간선의 개수 * 2이므로 24가 되고 이를 정점의 개수로 나누면 정점당 평균 2개의 간선이 연결되야한다. </p><p>이는 아래 그림과 같이 연결하면 된다.</p><p><img src="/image/32301/ex1.png" alt="img.png"></p><p>사이클을 이루게 한줄로 구성하면 정점당 2개의 간선이 연결되므로 소수를 유지할 수 있다.</p><p>만약 $M &#x3D;&#x3D; 2N$이면 정점의 개수는 12개, 간선의 개수는 24개가 나온다.</p><p>각 정점에 연결된 간선의 총합은 48이고 이를 정점의 개수로 나누면 정점당 평균 4개의 간선이 연결되야하지만 4는 소수가 아니기 때문에 6개의 정점은 간선이 3개 연결되고, 6개의 정점은 간선이 5개 연결되면 이를 해결할 수 있다.</p><p>$N$이 홀수인 경우는 계산이 살짝 다르겠지만, 결국 하나의 정점에 연결되는 간선의 수가 최대 5개이기 때문에, 각 정점에 연결된 간선을 <code>2, 3, 5</code>개로 잘 유지만 한다면 <code>1 2</code>를 제외한 모든 경우에서 소수를 유지할 수 있다.</p><p>그러면 어떻게 연결해서 소수를 유지할 수 있게 만들지 생각하면 된다.</p><p>정점을 아래처럼 6개씩 묶어 주면 쉽게 해결할 수 있다.</p><p><img src="/image/32301/ex2.png" alt="img.png"></p><p>정점이 6개 있을 때 제일 먼저 3칸씩 떨어진 정점들을 이어준다. <code>(1 - 4, 2 - 5, 3 - 6)</code></p><p>그러면 각 정점당 연결된 간선의 개수는 3개가 된다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span>&#125;);</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">2</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="/image/32301/ex3.png" alt="img_1.png"></p><p>그 다음 2칸씩 떨어진 정점 3개를 서로 이어준다. <code>(1 - 3, 1 - 5, 3 - 5)</code></p><p>그러면 1, 3, 5번째 정점에 연결된 간선의 개수는 5개, 나머지는 3개이다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">2</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="/image/32301/ex4.png" alt="img_2.png"></p><p>또 다른 2칸씩 떨어진 정점 3개를 묶어 서로 이어준다. <code>(2 - 4, 2 - 6, 4 - 6)</code></p><p>그러면 6개의 정점 모두 5개의 간선이 연결된다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">3</span>&#125;);</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">ans.<span class="built_in">push_back</span>(&#123;(i + <span class="number">1</span>) * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><p><img src="/image/32301/ex5.png" alt="img_3.png"></p><p>이 방법을 이용하여 간선의 개수를 $N$부터 시작해 $M$이 될 때까지 이를 반복하면 소수를 유지할 수 있다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N, M; cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> &amp;&amp; M == <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; ans;</span><br><span class="line">    ans.<span class="built_in">reserve</span>(<span class="number">3</span> * M);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> * N; i++) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;i, (i + <span class="number">1</span>) % (<span class="number">3</span> * N)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">int</span>)ans.<span class="built_in">size</span>() &lt; <span class="number">3</span> * M) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!step) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">2</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (step == <span class="number">1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">2</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">3</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;(i + <span class="number">1</span>) * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">            i += <span class="number">2</span>; step = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;[s, e] : ans) cout &lt;&lt; s + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/32301/1.png" alt="img_4.png"></p><p>한 정점에 5개까지만 연결해도 되는 것을 아는 것이 중요한 것 같다.</p><p>처음에는 6개의 정점마다 간선을 6개만 연결해서 홀수인 경우 약간의 예외처리가 필요했었는데 글을 쓰면서 정점마다 9개까지 할 수 있는 것이 보여서 다시 풀었다</p><p>처음 푼 방식은 아래에 남겨놓았다.</p><details><summary>코드 보기</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> N, M; cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> &amp;&amp; M == <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; ans;</span><br><span class="line">    ans.<span class="built_in">reserve</span>(<span class="number">3</span> * M);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> * N; i++) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;i, (i + <span class="number">1</span>) % (<span class="number">3</span> * N)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> step = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="type">int</span>)ans.<span class="built_in">size</span>() &lt; <span class="number">3</span> * M) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == N - <span class="number">1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, (i - <span class="number">1</span>) * <span class="number">3</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;(i - <span class="number">1</span>) * <span class="number">3</span>, (i - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;(i - <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>, i * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!step) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">1</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">2</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">            step ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, i * <span class="number">3</span> + <span class="number">2</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;i * <span class="number">3</span> + <span class="number">2</span>, (i + <span class="number">1</span>) * <span class="number">3</span> + <span class="number">1</span>&#125;);</span><br><span class="line">            step ^= <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;[s, e] : ans) cout &lt;&lt; s + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; e + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Graph-Theory/">Graph Theory</category>
      
      <category domain="https://ch2mi.github.io/tags/Ad-hoc/">Ad-hoc</category>
      
      <category domain="https://ch2mi.github.io/tags/Constructive/">Constructive</category>
      
      
      <comments>https://ch2mi.github.io/2024/12/20/32301/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 1948 임계경로 (C++)</title>
      <link>https://ch2mi.github.io/2024/12/15/1948/</link>
      <guid>https://ch2mi.github.io/2024/12/15/1948/</guid>
      <pubDate>Sun, 15 Dec 2024 10:07:50 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xOTQ4&quot;&gt;https://www.acmicpc.net/problem/1948&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;월드 나라는 모든 도로가 일방통행인 도로이고, 싸이클이 없다. 그런데 어떤 무수히 많은 사람들이 월드 나라의 지도를 그리기 위해서, 어떤 시작 도시로부터 도착 도시까지 출발을 하여 가능한 모든 경로를 탐색한다고 한다.&lt;/p&gt;
&lt;p&gt;이 지도를 그리는 사람들은 사이가 너무 좋아서 지도를 그리는 일을 다 마치고 도착 도시에서 모두 다 만나기로 하였다. 그렇다고 하였을 때 이들이 만나는 시간은 출발 도시로부터 출발한 후 최소 몇 시간 후에 만날 수 있는가? 즉, 마지막에 도착하는 사람까지 도착을 하는 시간을 의미한다.&lt;/p&gt;
&lt;p&gt;어떤 사람은 이 시간에 만나기 위하여 1분도 쉬지 않고 달려야 한다. 이런 사람들이 지나는 도로의 수를 카운트 하여라.&lt;/p&gt;
&lt;p&gt;출발 도시는 들어오는 도로가 0개이고, 도착 도시는 나가는 도로가 0개이다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xOTQ4">https://www.acmicpc.net/problem/1948<i class="fa fa-external-link-alt"></i></span></p><p>월드 나라는 모든 도로가 일방통행인 도로이고, 싸이클이 없다. 그런데 어떤 무수히 많은 사람들이 월드 나라의 지도를 그리기 위해서, 어떤 시작 도시로부터 도착 도시까지 출발을 하여 가능한 모든 경로를 탐색한다고 한다.</p><p>이 지도를 그리는 사람들은 사이가 너무 좋아서 지도를 그리는 일을 다 마치고 도착 도시에서 모두 다 만나기로 하였다. 그렇다고 하였을 때 이들이 만나는 시간은 출발 도시로부터 출발한 후 최소 몇 시간 후에 만날 수 있는가? 즉, 마지막에 도착하는 사람까지 도착을 하는 시간을 의미한다.</p><p>어떤 사람은 이 시간에 만나기 위하여 1분도 쉬지 않고 달려야 한다. 이런 사람들이 지나는 도로의 수를 카운트 하여라.</p><p>출발 도시는 들어오는 도로가 0개이고, 도착 도시는 나가는 도로가 0개이다.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>문제 시작에서 모든 도로가 일방통행이고, 싸이클이 없다고 했기 때문에 도로로 만들 수 있는 그래프는 방향 비순환 그래프, DAG가 된다. </p><p>DAG하면 제일 먼저 떠오르는 것은 위상정렬이기 때문에 위상정렬을 사용하는 쪽으로 문제를 접근했다.</p><p>출발 도시에서 시작해서 도착 도시에 모두 모이는 데 걸리는 시간을 계산해야 하므로 출발 도시에서 도착 도시까지의 최장 경로를 구하면 된다.</p><p>위상 정렬을 할 때 어떤 정점이 큐에 들어가기 위해서는 해당 정점으로 들어가는 간선에 대해 모두 계산이 완료되어야 한다. 즉 큐에 들어가는 순간 출발 정점에서 해당 정점까지 가는 모든 경로가 탐색되었으니 그 중에서 최댓값을 관리하고 있으면 된다.</p><p><code>vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt; arr(n);</code> </p><p>각 정점에 대한 정보를 위와 같은 형식으로 관리했다.</p><p><code>int</code>는 출발 정점에서 해당 정점까지가는 최장 경로를 의미한다.</p><p><code>vector&lt;int&gt;</code>는 추후 설명할 역추적을 위해 필요하며 이전 정점을 관리하고 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--indegree[nxt]) q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            <span class="keyword">if</span> (arr[cur].first + w &gt; arr[nxt].first) &#123;</span><br><span class="line">                arr[nxt].first = arr[cur].first + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위의 위상정렬 코드에서 nxt 정점까지 가는 경로보다 cur 정점에서 이동하는 경로가 클 때 최댓값 갱신을 해주면 위상 정렬이 완료되었을 때 각 정점까지의 최장 경로를 구할 수 있다.</p><p>다음으로 할 일은 최장 경로를 구했을 때 최장 경로로 가기 위한 도로의 수를 구해야 한다.</p><p>도로의 수가 어떤 것을 의미하는 것인지 잘 이해가 안될 수도 있는데 아래 예제를 보면 쉽게 알 수 있다.</p><p><img src="/image/1948/ex1.png" alt="alt text"></p><p>1 -&gt; 7로 가기 위한 최장 경로는 12이고, <code>1 -&gt; 2 -&gt; 6 -&gt; 7</code>과 <code>1 -&gt; 4 -&gt; 6 -&gt; 7</code> 두 개의 경로가 있다. 이 때 <code>6 -&gt; 7</code> 도로는 두 경로에서 공통적으로 사용하기 때문에 최장 경로에 필요한 도로의 개수는 총 5개이다.</p><p>최장 경로를 저장할 때 해당 최장 경로가 어떤 정점에서 왔는지 저장하고, 위상정렬이 끝난 후에 이를 역추적하면 쉽게 개수를 구할 수 있다.</p><p><img src="/image/1948/ex2.png" alt="alt text"></p><p>위의 그림과 같은 방법으로 최장 경로가 되는 이전 노드를 저장하면 된다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--indegree[nxt]) q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            <span class="keyword">if</span> (arr[cur].first + w &gt; arr[nxt].first) &#123;</span><br><span class="line">                arr[nxt].first = arr[cur].first + w;</span><br><span class="line">                arr[nxt].second = &#123;cur&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur].first + w == arr[nxt].first) &#123;</span><br><span class="line">                arr[nxt].second.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>이를 바탕으로 위상정렬 코드를 다시 구성했다.</p><p><code>vector&lt;pair&lt;int, vector&lt;int&gt;&gt;&gt; arr(n);</code> 에서 <code>vector&lt;int&gt;</code>부분이 바로 이를 위한 것이다.</p><p><code>if (arr[cur].first + w &gt; arr[nxt].first)</code> 이 경우에는 최댓값이 갱신될 때이므로 <code>arr[nxt].second</code> 에는 <code>cur</code>만 저장해준다.</p><p><code>else if (arr[cur].first + w == arr[nxt].first)</code> 이 경우에는 기존 최댓값과 현재 최댓값이 동일한 경우인데 모든 최장 경로에 대해 확인해야하므로 <code>cur</code>을 추가해주었다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    q.<span class="built_in">push</span>(e);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; nxt : arr[cur].second) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>위상정렬이 끝나고 위와 같이 역추적을 해주면 도로의 개수를 알 수 있다.</p><p><code>visited</code> 배열의 경우 한 노드의 진출 차수 중 2개 이상이 최장 경로에 해당되면 역추적할 때 2번 이상 뽑힐 수 있기 때문에 중복 검사가 필요하다.</p><p>최장 경로에 포함되는 정점에 대해 미리 저장해 놓은 직전 노드의 개수를 세면 최장 경로에 포함되는 모든 도로의 개수를 셀 수 있다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Topology_sort</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">arr</span>(n);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [e, w] : adj[i]) indegree[e]++;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt, w] : adj[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--indegree[nxt]) q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            <span class="keyword">if</span> (arr[cur].first + w &gt; arr[nxt].first) &#123;</span><br><span class="line">                arr[nxt].first = arr[cur].first + w;</span><br><span class="line">                arr[nxt].second = &#123;cur&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur].first + w == arr[nxt].first) &#123;</span><br><span class="line">                arr[nxt].second.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; arr[e].first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n)</span></span>;</span><br><span class="line">    q.<span class="built_in">push</span>(e);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (visited[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        visited[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; nxt : arr[cur].second) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(nxt);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    adj.<span class="built_in">assign</span>(n, vector&lt;array&lt;<span class="type">int</span>, <span class="number">2</span>&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> s, e, w;</span><br><span class="line">        cin &gt;&gt; s &gt;&gt; e &gt;&gt; w;</span><br><span class="line">        adj[s - <span class="number">1</span>].<span class="built_in">push_back</span>(&#123;e - <span class="number">1</span>, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s, e; cin &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    <span class="built_in">Topology_sort</span>(s - <span class="number">1</span>, e - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/1948/1.png" alt="alt text"></p><p>위상정렬한 뒤 역추적 아이디어가 정말 좋았던 문제이다.</p><p>단순하게 계산하면 한 정점에서 갈라졌다가 이후 정점에서 합쳐지는 경로가 모두 최장 경로일 때 문제가 생길 수 있으니 조심해야 한다.  </p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Graph-Traversal/">Graph Traversal</category>
      
      <category domain="https://ch2mi.github.io/tags/Graph-Theory/">Graph Theory</category>
      
      <category domain="https://ch2mi.github.io/tags/Topological-Sorting/">Topological Sorting</category>
      
      <category domain="https://ch2mi.github.io/tags/Directed-Acyclic-Graph/">Directed Acyclic Graph</category>
      
      
      <comments>https://ch2mi.github.io/2024/12/15/1948/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 16973 직사각형 탈출 (C++)</title>
      <link>https://ch2mi.github.io/2024/11/28/16973/</link>
      <guid>https://ch2mi.github.io/2024/11/28/16973/</guid>
      <pubDate>Thu, 28 Nov 2024 08:04:14 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xNjk3Mw==&quot;&gt;https://www.acmicpc.net/problem/16973&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;크기가 N×M인 격자판에 크기가 H×W인 직사각형이 놓여 있다. 격자판은 크기가 1×1인 칸으로 나누어져 있다. 격자판의 가장 왼쪽 위 칸은 (1, 1), 가장 오른쪽 아래 칸은 (N, M)이다. 직사각형의 가장 왼쪽 위칸은 $(S_r, S_c)$에 있을 때, 이 직사각형의 가장 왼쪽 위칸을 $(F_r, F_c)$로 이동시키기 위한 최소 이동 횟수를 구해보자.&lt;/p&gt;
&lt;p&gt;격자판의 각 칸에는 빈 칸 또는 벽이 있다. 직사각형은 벽이 있는 칸에 있을 수 없다. 또한, 직사각형은 격자판을 벗어날 수 없다.&lt;/p&gt;
&lt;p&gt;직사각형은 한 번에 왼쪽, 오른쪽, 위, 아래 중 한 방향으로 한 칸 이동시킬 수 있다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xNjk3Mw==">https://www.acmicpc.net/problem/16973<i class="fa fa-external-link-alt"></i></span></p><p>크기가 N×M인 격자판에 크기가 H×W인 직사각형이 놓여 있다. 격자판은 크기가 1×1인 칸으로 나누어져 있다. 격자판의 가장 왼쪽 위 칸은 (1, 1), 가장 오른쪽 아래 칸은 (N, M)이다. 직사각형의 가장 왼쪽 위칸은 $(S_r, S_c)$에 있을 때, 이 직사각형의 가장 왼쪽 위칸을 $(F_r, F_c)$로 이동시키기 위한 최소 이동 횟수를 구해보자.</p><p>격자판의 각 칸에는 빈 칸 또는 벽이 있다. 직사각형은 벽이 있는 칸에 있을 수 없다. 또한, 직사각형은 격자판을 벗어날 수 없다.</p><p>직사각형은 한 번에 왼쪽, 오른쪽, 위, 아래 중 한 방향으로 한 칸 이동시킬 수 있다.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>예제 1번으로 예를 들어보자.</p><p> 크기가 HxW인 직사각형을 빨간색 사각형이라고 한다면, 빨간색 사각형의 위치를 왼쪽 그림에서 오른쪽 그림으로 이동해야 한다.<br><img src="/image/16973/ex1.png" alt="alt text"></p><p>이때 중간에 있는 검은색 사각형이 벽이기 때문에 빨간색 사각형을 오른쪽으로 밀어서 이동할 수 없고 그림과 같이 아래로 돌아가야 한다.<br><img src="/image/16973/ex2.png" alt="alt text"></p><p>따라서 총 이동 횟수는 7번이 된다.</p><p>직사각형의 이동 방향에 벽이 없거나, 격자판을 벗어나지 않을 때만 직사각형을 움직여준다면 BFS로 간단하게 해결할 수 있다.</p><p><img src="/image/16973/ex3.png" alt="alt text"></p><p>위의 그림과 같이 이동하려는 방향에 따라 파란색 부분이 격자판을 벗어나지 않고, 전부 0일 때 아래 ismovable 함수에서 true를 반환해주었다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ismovable</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 위</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; W; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x - <span class="number">1</span>][y + i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 오른쪽</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y + W &gt;= M) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x + i][y + W]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 아래</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + H &gt;= N) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; W; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x + H][y + i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x + i][y - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>직사각형의 위치는 왼쪽 상단 모서리의 점을 유지해주면서 해당 방향으로 이동 가능하고, 아직 방문하지 않은 지점들에 대해 모두 탐색한다면<br>시간복잡도는 $O((N - H) * (M - W) * max(H, W))$이고, 제한시간이 2초이기 때문에 시간 내에 해결할 수 있다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, W, H, sx, sy, fx, fy;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; board;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ismovable</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 위</span></span><br><span class="line">    <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x - <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; W; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x - <span class="number">1</span>][y + i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 오른쪽</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y + W &gt;= M) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x + i][y + W]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 아래</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x + H &gt;= N) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; W; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x + H][y + i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y - <span class="number">1</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; H; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[x + i][y - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M));</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;sx - <span class="number">1</span>, sy - <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>[x, y, cnt] = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == fx - <span class="number">1</span> &amp;&amp; y == fy - <span class="number">1</span>) <span class="keyword">return</span> cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">ismovable</span>(k, x, y)) &#123;</span><br><span class="line">                <span class="type">int</span> i = x + dx[k];</span><br><span class="line">                <span class="type">int</span> j = y + dy[k];</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j]) &#123;</span><br><span class="line">                    visited[i][j] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    board.<span class="built_in">assign</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : board) <span class="keyword">for</span> (<span class="type">int</span>&amp; j : i) cin &gt;&gt; j;</span><br><span class="line">    cin &gt;&gt; H &gt;&gt; W &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">BFS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/16973/1.png" alt="alt text"></p><p>보통 BFS를 할 때 점을 이동시키는 문제들은 많이 풀어봤었는데 도형을 이동시키는 문제는 잘 안풀어봤던 것 같다. 이동 방향에 벽이 있는지 검사를 구현할 때 조심한다면 무난한 BFS문제라고 생각한다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Graph-Traversal/">Graph Traversal</category>
      
      <category domain="https://ch2mi.github.io/tags/BFS/">BFS</category>
      
      
      <comments>https://ch2mi.github.io/2024/11/28/16973/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 3878 점 분리 (C++)</title>
      <link>https://ch2mi.github.io/2024/11/24/3878/</link>
      <guid>https://ch2mi.github.io/2024/11/24/3878/</guid>
      <pubDate>Sun, 24 Nov 2024 09:12:20 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8zODc4&quot;&gt;https://www.acmicpc.net/problem/3878&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;평면 위에 여러 개의 검정 점과 흰 점이 있다. 이때, 길이가 무한대인 직선을 그어 흰 점과 검은 점을 분리하려고 한다. 직선은 어떤 점과도 만나면 안 된다. 직선으로 인해서 나누어지는 두 그룹 중 한 그룹에는 흰 점만 있어야 하고, 다른 그룹에는 검은 점만 있어야 한다.&lt;/p&gt;
&lt;p&gt;아래 그림에서 제일 왼쪽 예제는 점선으로 표시된 직선으로 두 점을 나눌 수 있다. 하지만 나머지 예제는 직선으로 점을 분리할 수 없다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/3878/ex1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;흰 점과 검은 점의 좌표가 주어졌을 때, 직선으로 점을 분리할 수 있는지 없는지를 알아내는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8zODc4">https://www.acmicpc.net/problem/3878<i class="fa fa-external-link-alt"></i></span></p><p>평면 위에 여러 개의 검정 점과 흰 점이 있다. 이때, 길이가 무한대인 직선을 그어 흰 점과 검은 점을 분리하려고 한다. 직선은 어떤 점과도 만나면 안 된다. 직선으로 인해서 나누어지는 두 그룹 중 한 그룹에는 흰 점만 있어야 하고, 다른 그룹에는 검은 점만 있어야 한다.</p><p>아래 그림에서 제일 왼쪽 예제는 점선으로 표시된 직선으로 두 점을 나눌 수 있다. 하지만 나머지 예제는 직선으로 점을 분리할 수 없다.</p><p><img src="/image/3878/ex1.png"></p><p>흰 점과 검은 점의 좌표가 주어졌을 때, 직선으로 점을 분리할 수 있는지 없는지를 알아내는 프로그램을 작성하시오.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>흰 점과 검은 점을 직선을 통해 분리하기 위해선 두 점의 집합이 서로 겹친 부분이 있는지 확인해야 한다.</p><p>두 점의 집합이 서로 겹치는 부분이 존재하거나, 한 집합이 다른 집합 안에 포함되어 있다면 직선을 통해 분리 할 수 없고, 두 집합이 겹쳐 있지 않을 때만 직선으로 분리할 수 있다.</p><p>그러면 두 집합의 경계를 정해야 하는데 이를 위해 컨벡스 헐 알고리즘을 사용했다.</p><p>흰 점과 검은 점에 대해 각각의 컨벡스 헐을 구하면 흰 점의 컨벡스 헐 내부에는 모든 흰 점이 존재하고, 검은 점의 컨벡스 헐 내부에는 모든 검은 점이 존재한다. </p><p>즉 컨벡스 헐이 집합의 경계를 의미하기 때문에 두 컨벡스헐이 교차하는지 검사하면 직선을 통해 분리할 수 있는지 없는지 확인 할 수 있다.</p><p>컨벡스 헐을 만드는 알고리즘은 그라함 스캔 방식을 이용했다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;point&gt; <span class="title">ConvexHull</span><span class="params">(vector&lt;point&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), [&amp;](point&amp; a, point&amp; b) &#123;</span><br><span class="line">        <span class="type">int</span> ccw = <span class="built_in">CCW</span>(v[<span class="number">0</span>], a, b);</span><br><span class="line">        <span class="keyword">if</span> (!ccw) <span class="keyword">return</span> <span class="built_in">dist</span>(v[<span class="number">0</span>], a) &lt; <span class="built_in">dist</span>(v[<span class="number">0</span>], b);</span><br><span class="line">        <span class="keyword">return</span> ccw &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>)v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = st.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CCW</span>(v[b], v[a], v[i]) &gt; <span class="number">0</span>) st.<span class="built_in">push</span>(a), st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span> i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">c</span><span class="params">(st.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : c) p = v[st.<span class="built_in">top</span>()], st.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>흰 점과 검은 점의 컨벡스 헐을 구한 다음엔 완전 탐색을 통해 두 컨벡스 헐의 변이 서로 교차하는 지 확인했다. 만약 어떤 두 변이 교차한다면 두 집합이 겹치는 부분이 있다는 뜻이므로 직선으로 분리할 수 없다는 의미가 된다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;point&gt; bc = <span class="built_in">ConvexHull</span>(black), wc = <span class="built_in">ConvexHull</span>(white);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 두 컨벡스 헐이 교차하는지 판정</span></span><br><span class="line"><span class="type">int</span> bl = (<span class="type">int</span>)bc.<span class="built_in">size</span>(), wl = (<span class="type">int</span>)wc.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bl; i++) &#123;</span><br><span class="line">    point p1 = bc[i], p2 = bc[(i + <span class="number">1</span>) % bl];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wl; j++) &#123;</span><br><span class="line">        point p3 = wc[j], p4 = wc[(j + <span class="number">1</span>) % wl];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">intersect</span>(p1, p2, p3, p4)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>교차 판정을 위해 선분 교차 문제에 사용한 알고리즘을 이용했다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(point&amp; a, point&amp; b, point&amp; c, point&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ab = <span class="built_in">CCW</span>(a, b, c) * <span class="built_in">CCW</span>(a, b, d);</span><br><span class="line">    <span class="type">int</span> cd = <span class="built_in">CCW</span>(c, d, a) * <span class="built_in">CCW</span>(c, d, b);</span><br><span class="line">    <span class="keyword">if</span> (!ab &amp;&amp; !cd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (c &gt; d) <span class="built_in">swap</span>(c, d);</span><br><span class="line">        <span class="keyword">return</span> a &lt;= d &amp;&amp; c &lt;= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ab &lt;= <span class="number">0</span> &amp;&amp; cd &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 한 컨벡스 헐이 다른 컨벡스 헐에 포함되어 있다면 변이 서로 교차하지 않기 때문에 교차만으로는 확인할 수 없다.</p><p>따라서 두 컨벡스 헐을 구성하는 점들을 합쳐 새로운 컨벡스 헐을 구성해보았다.</p><p>이때 새롭게 만들어지는 컨벡스 헐이 기존 두 컨벡스 헐 중 겹치는 컨벡스 헐이 있다면 두 컨벡스 헐은 포함 관계가 되기 때문에 직선으로 분리할 수가 없다.</p><p>따라서 새로운 컨벡스 헐이 만들어졌다면 두 집합은 완전히 분리가 되어 있다는 의미이기 때문에 직선으로 분리할 수 있다고 판정할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 두 컨벡스 헐로 새로운 컨벡스 헐을 만든다.</span></span><br><span class="line"><span class="function">vector&lt;point&gt; <span class="title">sum</span><span class="params">(bc)</span></span>;</span><br><span class="line">sum.<span class="built_in">insert</span>(sum.<span class="built_in">end</span>(), wc.<span class="built_in">begin</span>(), wc.<span class="built_in">end</span>());</span><br><span class="line">vector&lt;point&gt; sumc = <span class="built_in">ConvexHull</span>(sum);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (sumc != bc &amp;&amp; sumc != wc);</span><br></pre></td></tr></table></figure><p>흰 점과 검은 점이 각각 100개 이하이기 때문에 위와 같은 방식으로 분리할 수 있는지 검사를 해도 시간이 충분하다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; point;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCW</span><span class="params">(point&amp; a, point&amp; b, point&amp; c)</span> </span>&#123;</span><br><span class="line">    ll ans = a.x * b.y + b.x * c.y + c.x * a.y - (b.x * a.y + c.x * b.y + a.x * c.y);</span><br><span class="line">    <span class="keyword">if</span> (ans &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dist</span><span class="params">(point&amp; a, point&amp; b)</span> </span>&#123;</span><br><span class="line">    ll dx = b.x - a.x, dy = b.y - a.y;</span><br><span class="line">    <span class="keyword">return</span> (dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;point&gt; <span class="title">ConvexHull</span><span class="params">(vector&lt;point&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">1</span>, v.<span class="built_in">end</span>(), [&amp;](point&amp; a, point&amp; b) &#123;</span><br><span class="line">        <span class="type">int</span> ccw = <span class="built_in">CCW</span>(v[<span class="number">0</span>], a, b);</span><br><span class="line">        <span class="keyword">if</span> (!ccw) <span class="keyword">return</span> <span class="built_in">dist</span>(v[<span class="number">0</span>], a) &lt; <span class="built_in">dist</span>(v[<span class="number">0</span>], b);</span><br><span class="line">        <span class="keyword">return</span> ccw &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="type">int</span>)v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = st.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CCW</span>(v[b], v[a], v[i]) &gt; <span class="number">0</span>) st.<span class="built_in">push</span>(a), st.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">else</span> i--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">c</span><span class="params">(st.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : c) p = v[st.<span class="built_in">top</span>()], st.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(point&amp; a, point&amp; b, point&amp; c, point&amp; d)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ab = <span class="built_in">CCW</span>(a, b, c) * <span class="built_in">CCW</span>(a, b, d);</span><br><span class="line">    <span class="type">int</span> cd = <span class="built_in">CCW</span>(c, d, a) * <span class="built_in">CCW</span>(c, d, b);</span><br><span class="line">    <span class="keyword">if</span> (!ab &amp;&amp; !cd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b) <span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">if</span> (c &gt; d) <span class="built_in">swap</span>(c, d);</span><br><span class="line">        <span class="keyword">return</span> a &lt;= d &amp;&amp; c &lt;= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ab &lt;= <span class="number">0</span> &amp;&amp; cd &lt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">separate</span><span class="params">(vector&lt;point&gt;&amp; black, vector&lt;point&gt;&amp; white)</span> </span>&#123;</span><br><span class="line">    vector&lt;point&gt; bc = <span class="built_in">ConvexHull</span>(black), wc = <span class="built_in">ConvexHull</span>(white);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 두 컨벡스 헐이 교차하는지 판정</span></span><br><span class="line">    <span class="type">int</span> bl = (<span class="type">int</span>)bc.<span class="built_in">size</span>(), wl = (<span class="type">int</span>)wc.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bl; i++) &#123;</span><br><span class="line">        point p1 = bc[i], p2 = bc[(i + <span class="number">1</span>) % bl];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; wl; j++) &#123;</span><br><span class="line">            point p3 = wc[j], p4 = wc[(j + <span class="number">1</span>) % wl];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">intersect</span>(p1, p2, p3, p4)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 두 컨벡스 헐로 새로운 컨벡스 헐을 만든다.</span></span><br><span class="line">    <span class="function">vector&lt;point&gt; <span class="title">sum</span><span class="params">(bc)</span></span>;</span><br><span class="line">    sum.<span class="built_in">insert</span>(sum.<span class="built_in">end</span>(), wc.<span class="built_in">begin</span>(), wc.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;point&gt; sumc = <span class="built_in">ConvexHull</span>(sum);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (sumc != bc &amp;&amp; sumc != wc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="function">vector&lt;point&gt; <span class="title">black</span><span class="params">(n)</span>, <span class="title">white</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : black) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, y] : white) cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">separate</span>(black, white)) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/3878/1.png" alt="alt text"></p><p>처음 제출할 땐 새로운 컨벡스 헐을 만들고 나서 완전히 일치하지 않을까봐 아래와 같이 정렬을 다시 하고 검사했다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(bc.<span class="built_in">begin</span>(), bc.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(wc.<span class="built_in">begin</span>(), wc.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(sumc.<span class="built_in">begin</span>(), sumc.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> (sumc != bc &amp;&amp; sumc != wc);</span><br></pre></td></tr></table></figure><p>곰곰히 생각해 봤을 때 컨벡스 헐을 만들 때 $x_{min}$을 기준으로 반시계 방향으로 돌아가면서 컨벡스 헐을 구성하기 때문에 정렬하지 않아도 일치할 것이라 생각해서 다시 제출했고 동일하다는 것을 확인할 수 있었다.</p><p>또한 정답을 맞춘 후 태그를 보니 “볼록 다각형 내부의 점 판정”이 따로 있는 것을 보아 관련 알고리즘도 공부해야겠다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Geometry/">Geometry</category>
      
      <category domain="https://ch2mi.github.io/tags/Convex-Hull/">Convex Hull</category>
      
      <category domain="https://ch2mi.github.io/tags/Line-Segment-Intersection-Check/">Line Segment Intersection Check</category>
      
      
      <comments>https://ch2mi.github.io/2024/11/24/3878/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[Codeforces] Codeforces Round 988 (Div. 3) 후기</title>
      <link>https://ch2mi.github.io/2024/11/18/codeforces-988/</link>
      <guid>https://ch2mi.github.io/2024/11/18/codeforces-988/</guid>
      <pubDate>Mon, 18 Nov 2024 06:29:56 GMT</pubDate>
      
      <description>&lt;p&gt;최근 백준 닉네임에 색을 칠하고 싶어 Codeforces를 시작하게 되었다.&lt;/p&gt;
&lt;p&gt;시작한지 얼마 되지 않아서 Div. 2에서 벽을 많이 느꼈었는데, 이번 Div. 3에서 자신감을 되찾고자 참가하게 되었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/image/codeforces-988/before.png&quot; alt=&quot;alt text&quot;&gt;&lt;/p&gt;
&lt;p&gt;그리고 이번 Div. 3에서 Rating을 103점 이상 얻으면 &lt;span style=&quot;color: #008000&quot;&gt; Pupil &lt;/span&gt;을 갈 수 있기 때문에 기대를 가지고 참가했다.&lt;/p&gt;
&lt;p&gt;Contest 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzIwMzc=&quot;&gt;Codeforces Round 988 (Div. 3)&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>최근 백준 닉네임에 색을 칠하고 싶어 Codeforces를 시작하게 되었다.</p><p>시작한지 얼마 되지 않아서 Div. 2에서 벽을 많이 느꼈었는데, 이번 Div. 3에서 자신감을 되찾고자 참가하게 되었다.</p><p><img src="/image/codeforces-988/before.png" alt="alt text"></p><p>그리고 이번 Div. 3에서 Rating을 103점 이상 얻으면 <span style="color: #008000"> Pupil </span>을 갈 수 있기 때문에 기대를 가지고 참가했다.</p><p>Contest 링크 : <span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzIwMzc=">Codeforces Round 988 (Div. 3)<i class="fa fa-external-link-alt"></i></span></p><span id="more"></span><h3 id="A-Twice"><a href="#A-Twice" class="headerlink" title="A.  Twice "></a>A. <span style="color: #00A000"> Twice </span></h3><p>길이가 $n$인 정수 배열 $a$가 주어진다.</p><p>주어진 입력에서 $1 \leq i &lt; j \leq n$인 $i, j$에 대해 $a_i &#x3D; a_j$를 만족하는 개수를 찾는 문제였다.</p><p>모든 입력을 <code>map&lt;int, int&gt;</code>에 넣고 map을 모두 순회하면서 2로 나눈 값을 <code>cnt</code>변수에 모두 더해주었다.</p><details><summary>코드 보기</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a; cin &gt;&gt; a;</span><br><span class="line">            m[a]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : m) cnt += i.second / <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="B-Intercepted-Inputs"><a href="#B-Intercepted-Inputs" class="headerlink" title="B.  Intercepted Inputs "></a>B. <span style="color: #00A000"> Intercepted Inputs </span></h3><p>길이가 $k$인 정수 배열 $a_k$가 주어진다.</p><p>정수 배열에는 $n, m$과 $n * m$ 만큼의 원소가 포함되어 있는데 값들의 순서가 무작위로 섞여 한 줄로 주어진다.</p><p>그래서 원래 배열을 복원하기 위해 $n, m$을 찾는 문제이다.</p><p>임의의 $a_i, a_j$를 골라서 $a_i * a_j &#x3D; k - 2$를 만족하는지 확인하면 된다.</p><p>A번과 마찬가지로 입력을 전부 <code>map&lt;int, int&gt;</code>에 저장하고 반복문을 $1$부터 $k - 2$까지 반복했다.</p><p>$k - 2$에 나누어 떨어지는 $i$를 대상으로 map에 $i$와 $(k - 2) &#x2F; i$가 모두 존재하면 $n, m$을 찾았으므로 이를 출력하고 반복문을 종료하면 된다.</p><details><summary>코드 보기</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> k; cin &gt;&gt; k;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a; cin &gt;&gt; a;</span><br><span class="line">            m[a]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((k - <span class="number">2</span>) % i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">find</span>(i) != m.<span class="built_in">end</span>() &amp;&amp; m.<span class="built_in">find</span>((k - <span class="number">2</span>) / i) != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == (k - <span class="number">2</span>) / i &amp;&amp; m[i] &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (k - <span class="number">2</span>) / i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <h3 id="C-Superultra’s-Favorite-Permutation"><a href="#C-Superultra’s-Favorite-Permutation" class="headerlink" title="C.  Superultra’s Favorite Permutation "></a>C. <span style="color: #00A000"> Superultra’s Favorite Permutation </span></h3><p>$n$이 주어진다.</p><p>주어진 입력에서 모든 $1 \leq i \leq n - 1$ 에 대해 $p_i + p_{i + 1}$는 합성수를 만족해야하고 $p$가 순열이 되도록 값을 구성해야 한다.</p><p>이때 불가능 하면 -1을 출력하고 가능하면 $p$를 출력하면 된다.</p><p>$n$이 1일 때부터 가능한 경우를 구성해 보았는데 $n$이 5일 때부터 아래와 같이 조건에 맞는 순열이 만들어지는 것을 알 수 있었다.<br>$$[1, 3, 5, 4, 2]$$</p><p>5 이상일 때 어떻게 순열을 구성해야 하는지 고민을 좀 오래 했는데 홀수끼리 더하면 항상 짝수가 나오고 짝수끼리 더하면 항상 짝수가 나오기 때문에 이 성질을 이용하면 될 것이라 생각했다.</p><p>왼쪽에는 홀수만 몰아넣고, 오른쪽에는 짝수만 몰아 넣은 다음 홀수와 짝수가 만나는 부분엔 더했을 때 소수가 나오지 않는 수를 붙여 놓으면 된다.</p><p>이때 홀수와 짝수가 만나는 부분엔 5와 4를 배치하면 $p_i + p_{i + 1}$는 합성수를 항상 만족할 수 있다.</p><details><summary>코드 보기</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) <span class="keyword">continue</span>;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="number">5</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">4</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="D-Sharky-Surfing"><a href="#D-Sharky-Surfing" class="headerlink" title="D.  Sharky Surfing "></a>D. <span style="color: #00A000"> Sharky Surfing </span></h3><p>$n, m, L$이 주어진다.</p><p>$n$은 장애물의 개수, $m$은 파워업 아이템의 개수, $L$은 도착 할 지점이다.</p><p>이후 $n$개의 장애물이 존재하는 구간 $[l, r]$과 $m$개의 파워업의 (위치 $x_i$, 크기 $v_i$)가 주어진다.</p><p>점프력이 $k$이고 현재 위치가 $x$일 때 구간 $[x, x + k]$ 사이 위치로 원하는 만큼 이동할 수 있고 이동하려는 위치에 장애물이 존재하면 해당 위치로 이동할 수 없다.</p><p>파워업 아이템을 먹으면 점프력이 $v_i$만큼 증가한다.</p><p>시작 위치가 1, 점프력이 1일 때 $L$에 도착하기 위해 필요한 파워업 아이템의 최소 개수를 구해야 한다.</p><p>장애물을 한 개씩 모두 지나가면서 장애물을 건널 수 없으면 장애물을 건널 수 있을 때까지 파워업 아이템을 먹으면 된다.</p><p>이때 파워업 아이템을 먹는 개수를 최소화해야 하기 때문에 <code>priority_queue&lt;int&gt;</code>를 사용해 점프력이 많이 증가하는 아이템부터 먹었다.</p><p>연속한 두 장애물 사이에 존재하는 파워업 아이템을 <code>upper_bound</code>를 이용해 모두 <code>priority_queue</code>에 넣어놓고 장애물을 건널 수 없으면 건널 수 있을 때까지 먹어주었다. </p><p><code>priority_queue</code>가 비어있다면 다 먹었어도 건널 수 없는 경우이기 때문에 -1을 출력해주고 그렇지 않다면 계속해서 전진했다.</p><details><summary>코드 보기</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m, L; cin &gt;&gt; n &gt;&gt; m &gt;&gt; L;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">v1</span>(n), <span class="built_in">v2</span>(m);</span><br><span class="line">        <span class="comment">// 장애물</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [l, r] : v1) cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 파워업</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [x, v] : v2) cin &gt;&gt; x &gt;&gt; v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 파워업 후보</span></span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; L) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">upper_bound</span>(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), v1[p1]) - v<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = p2; i &lt; p; i++) pq.<span class="built_in">push</span>(v2[i].second);</span><br><span class="line">            <span class="keyword">while</span> (v1[p1].second - v1[p1].first + <span class="number">2</span> &gt; sum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    cnt = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += pq.<span class="built_in">top</span>();</span><br><span class="line">                cnt++;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            p1++;</span><br><span class="line">            p2 = p;</span><br><span class="line">            <span class="keyword">if</span> (p1 == n) <span class="keyword">break</span>;</span><br><span class="line">            cur = v1[p1].first - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>&nbsp;<p>구현을 제대로 한 것 같지 않고, 시간 복잡도도 확신이 들지 않아 WA나 TLE를 예상했었는데 의외로 한번에 Accepted가 나와서 놀랐다. </p><h3 id="E-Kachina’s-Favorite-Binary-String"><a href="#E-Kachina’s-Favorite-Binary-String" class="headerlink" title="E.  Kachina’s Favorite Binary String "></a>E. <span style="color: #ff0000"> Kachina’s Favorite Binary String </span></h3><p>인터렉티브 문제이다.</p><p>어떤 이진 문자열에 대해 길이 $n$이 주어진다.</p><p>우리가 “? a b”라고 질의하면 $[a, b]$ 내에 존재하는 “01”형태의 서브 시퀀스의 개수를 알려준다.</p><p>예를 들어 문자열이 “0010”일 때 “? 1 4”라고 질의 하면 서브 시퀀스는 $(a_1(0), a_3(1))$과 $(a_2(0), a_3(1))$ 두 개 존재하므로 2라고 답변한다.</p><p>길이 $n$의 문자열에 대해 질의를 최대 $n$번 할 수 있을 때 문자열을 확인할 수 있으면 정답 문자열 s에 대해 “! s”를 출력하고 확인할 수 없다면 “! IMPOSSIBLE”을 출력해야 한다.</p><p>D번까지는 풀이법이 바로 바로 생각나서 어렵지 않게 풀 수 있었는데 해당 문제는 풀이법 조차 생각나지 않았다.</p><p>힘들게 고민하다가 옳은 풀이인지는 모르겠고 아무 방법이나 사용해보자 해서 앞에서 부터 3개씩 확인해보기로 했다.</p><p>숫자 3개에 대해 나올 수 있는 조합과 01 서브 시퀀스의 개수는 아래와 같다.<br>$$ 000(0), 001(2), 010(1), 011(2), 100(0), 101(1), 110(0), 111(1) $$</p><p>결과가 1이면 010, 101 중 하나이므로 구간의 길이를 2로 줄여서 다시 질의하면 알 수 있고</p><p>2일 때도 001, 011이므로 구간의 길이를 2로 줄이면 된다.</p><p>0일 때는 알 수 없으므로 한칸 뒤로 가서 다시 질의하는 방식으로 구현했다.</p><p><img src="/image/codeforces-988/E.png" alt="alt text"></p><p>당연히 모두 WA가 나왔다.</p><p>결국 풀지 못하고 Contest가 종료되었다.</p><h3 id="F-Ardent-Flames-G-Natlan-Exploring"><a href="#F-Ardent-Flames-G-Natlan-Exploring" class="headerlink" title="F.  Ardent Flames , G.  Natlan Exploring "></a>F. <span style="color: #808080"> Ardent Flames </span>, G. <span style="color: #808080"> Natlan Exploring </span></h3><p>E번을 푸느라 두 문제 모두 풀지 못했다.</p><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/codeforces-988/score.png" alt="alt text"></p><p>푼 문제들은 다 한 번에 Accepted를 받은 것이 좀 의외였다.</p><p>E번을 풀 수 있었으면 좋았을텐데 Contest가 끝나고 풀이를 봤을 때 전혀 생각하지 못한 방법이었어서 아쉬움은 덜했다.</p><p><img src="/image/codeforces-988/C.png" alt="alt text"></p><p>C번 풀 때 홀수 &#x2F; 짝수 모으기를 생각 안한 상태에서 일정 개수 넘어가면 뒤에 덧붙이면 되지 않을 까란 생각에 하드 코딩하다가 $n &#x3D;8$에서 갑자기 순열이 확 바뀌다보니까 하드 코딩을 멈추고 규칙성을 찾기 시작했는데 정말 잘한 것 같다.</p><p><img src="/image/codeforces-988/result.png" alt="alt text"></p><p>무사히 <span style="color: #008000"> Pupil </span>을 갈 수 있었다</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/Codeforces/">Codeforces</category>
      
      
      
      <comments>https://ch2mi.github.io/2024/11/18/codeforces-988/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 4095 최대 정사각형 (C++)</title>
      <link>https://ch2mi.github.io/2024/11/12/4095/</link>
      <guid>https://ch2mi.github.io/2024/11/12/4095/</guid>
      <pubDate>Tue, 12 Nov 2024 10:22:25 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS80MDk1&quot;&gt;https://www.acmicpc.net/problem/4095&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1과 0으로 이루어진 NxM크기의 행렬이 주어졌을 때, 1로만 이루어진 가장 큰 정사각형 부분 행렬 찾는 프로그램을 작성하시오. &lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS80MDk1">https://www.acmicpc.net/problem/4095<i class="fa fa-external-link-alt"></i></span></p><p>1과 0으로 이루어진 NxM크기의 행렬이 주어졌을 때, 1로만 이루어진 가장 큰 정사각형 부분 행렬 찾는 프로그램을 작성하시오. </p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>다이나믹 프로그래밍을 이용하면 쉽게 풀 수 있다.</p><p>$N * M$크기의 dp 배열을 만들고, dp[i][j]의 의미를 $A_{ij}$를 정사각형의 우측 하단 꼭지점으로 했을 때 만들어지는 최대 정사각형의 크기라고 생각하면 된다.</p><p>1번 테스트 케이스로 예시로 들면 아래와 같다.<br>왼쪽이 입력값과 만들어지는 정사각형이고 오른쪽이 dp 배열일 때 정사각형의 크기마다 그림으로 그려보았다.<br><img src="/image/4095/ex1.png"><br><img src="/image/4095/ex2.png"><br><img src="/image/4095/ex3.png"></p><p>위의 내용을 바탕으로 dp 배열을 채우기 위해서는 4가지 경우를 생각하면 된다.</p><ol><li>$A_{ij} &#x3D;&#x3D; 0$ : 이 때에는 정사각형이 만들어질 수 없으므로 dp[i][j] &#x3D; 0이다.</li><li>$i &#x3D;&#x3D; 0$ 또는 $j &#x3D;&#x3D; 0$ : 이 때에는 만들어질 수 있는 가장 큰 정사각형의 길이가 1이므로 dp[i][j] &#x3D; 1이다.</li><li>$A_{i-1j} &#x3D;&#x3D; 0$ 또는 $A_{ij-1} &#x3D;&#x3D; 0$ 또는 $A_{i-1j-1} &#x3D;&#x3D; 0$ : 이 때에는 2 이상의 정사각형을 만들 수 없으므로 dp[i][j] &#x3D; 1이다.</li><li>$A_{i-1j} &#x3D;&#x3D; 1$ 그리고 $A_{ij-1} &#x3D;&#x3D; 1$ 그리고 $A_{i-1j-1} &#x3D;&#x3D; 1$ : 이 때에는 2 이상의 정사각형을 만들 수 있으므로 (dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) 중 최솟값에서 1을 더한 값이 dp[i][j]의 값이 된다.</li></ol><p>총 4가지 경우로 조건을 나누어 dp 배열을 채워주면 된다.</p><p>이 때 4번에서 (dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) 세 값 중 하나에서 0이 있는 경우가 사실 3번과 같은 경우기 때문에 1, 2, 4번 세가지 조건만 따져주어도 같은 결과가 나온다.</p><p>dp 배열을 채우면서 최댓값을 계속 갱신해주면 가장 큰 정사각형의 너비 또는 높이를 구할 수 있다.   </p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">1001</span>][<span class="number">1001</span>], dp[<span class="number">1001</span>][<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> N, M; cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">        <span class="keyword">if</span> (!N &amp;&amp; !M) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) </span><br><span class="line">                cin &gt;&gt; arr[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!arr[i][j]) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!i || !j) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">min</span>(&#123;dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/4095/1.png"><br>처음 구현할 때 1번, 2+3번, 4번 조건으로 나누어서 코드를 구현했는데 글을 쓰다 보니 사실 3번 조건이 4번 조건에서 처리되어 1번, 2번, 4번 조건만으로 충분하다는 것을 알 수 있었다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Dp/">Dp</category>
      
      
      <comments>https://ch2mi.github.io/2024/11/12/4095/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 1944 복제 로봇 (C++)</title>
      <link>https://ch2mi.github.io/2024/10/28/1944/</link>
      <guid>https://ch2mi.github.io/2024/10/28/1944/</guid>
      <pubDate>Mon, 28 Oct 2024 09:01:32 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xOTQ0&quot;&gt;https://www.acmicpc.net/problem/1944&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;세준이는 어느 날 획기적인 로봇을 한 개 개발하였다. 그 로봇은 복제 장치를 이용하면 자기 자신을 똑같은 로봇으로 원하는 개수만큼 복제시킬 수 있다. 세준이는 어느 날 이 로봇을 테스트하기 위하여 어떤 미로에 이 로봇을 풀어 놓았다. 이 로봇의 임무는 미로에 흩어진 열쇠들을 모두 찾는 것이다. 그리고 열쇠가 있는 곳들과 로봇이 출발하는 위치에 로봇이 복제할 수 있는 장치를 장착해 두었다.&lt;/p&gt;
&lt;p&gt;N*N의 정사각형 미로와 M개의 흩어진 열쇠의 위치, 그리고 이 로봇의 시작 위치가 주어져 있을 때, 모든 열쇠를 찾으면서 로봇이 움직이는 횟수의 합을 최소로 하는 프로그램을 작성하여라. 로봇은 상하좌우 네 방향으로 움직이며, 로봇이 열쇠가 있는 위치에 도달했을 때 열쇠를 찾은 것으로 한다. (복제된 로봇이어도 상관없다) 하나의 칸에 동시에 여러 개의 로봇이 위치할 수 있으며, 로봇이 한 번 지나간 자리라도 다른 로봇 또는 자기 자신이 다시 지나갈 수 있다. 복제에는 시간이 들지 않으며, 로봇이 움직이는 횟수의 합은 분열된 로봇 각각이 움직인 횟수의 총 합을 말한다. 복제된 로봇이 열쇠를 모두 찾은 후 같은 위치로 모일 필요는 없다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8xOTQ0">https://www.acmicpc.net/problem/1944<i class="fa fa-external-link-alt"></i></span></p><p>세준이는 어느 날 획기적인 로봇을 한 개 개발하였다. 그 로봇은 복제 장치를 이용하면 자기 자신을 똑같은 로봇으로 원하는 개수만큼 복제시킬 수 있다. 세준이는 어느 날 이 로봇을 테스트하기 위하여 어떤 미로에 이 로봇을 풀어 놓았다. 이 로봇의 임무는 미로에 흩어진 열쇠들을 모두 찾는 것이다. 그리고 열쇠가 있는 곳들과 로봇이 출발하는 위치에 로봇이 복제할 수 있는 장치를 장착해 두었다.</p><p>N*N의 정사각형 미로와 M개의 흩어진 열쇠의 위치, 그리고 이 로봇의 시작 위치가 주어져 있을 때, 모든 열쇠를 찾으면서 로봇이 움직이는 횟수의 합을 최소로 하는 프로그램을 작성하여라. 로봇은 상하좌우 네 방향으로 움직이며, 로봇이 열쇠가 있는 위치에 도달했을 때 열쇠를 찾은 것으로 한다. (복제된 로봇이어도 상관없다) 하나의 칸에 동시에 여러 개의 로봇이 위치할 수 있으며, 로봇이 한 번 지나간 자리라도 다른 로봇 또는 자기 자신이 다시 지나갈 수 있다. 복제에는 시간이 들지 않으며, 로봇이 움직이는 횟수의 합은 분열된 로봇 각각이 움직인 횟수의 총 합을 말한다. 복제된 로봇이 열쇠를 모두 찾은 후 같은 위치로 모일 필요는 없다.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>문제를 요약해보면 시작 위치 S에서부터 열쇠가 있는 위치 K를 모두 들리는 최단 경로를 찾는 문제이다. </p><p>S와 K를 모두 정점으로 놓았을 때 각 정점에서 로봇이 분열할 수 있고, 하나의 로봇이라도 정점에 도착하면 되기 때문에 모든 정점을 최소 가중치로 연결하는 MST를 구하면 된다.</p><p>그래서 먼저 BFS를 이용해 그래프를 만들고, 그래프의 MST를 구하면 된다.</p><p>정점 정보는 <code>map&lt;pair&lt;int, int&gt;, int&gt;&gt;</code>에서 x, y좌표를 넣으면 정점의 인덱스를 반환하게 했고, S &#x3D; 0, K &#x3D; 1, 2, 3, … 순으로 번호를 매겼다.</p><p>각 정점마다 BFS를 돌면서 다른 정점과 연결 상태를 확인했다.<br>정점과 연결이 되어있으면 그래프에 <code>&#123;도착노드, 거리&#125;</code> 형태로 저장을 한다.</p><p>이때 BFS를 모든 정점에 대해 돌기 때문에 단방향으로 저장을 했다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 그래프를 만든다.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = v[&#123;sx, sy&#125;];</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N));</span><br><span class="line">    queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, sx, sy&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_w, cur_x, cur_y] = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_x &lt; <span class="number">0</span> || cur_x &gt;= N || cur_y &lt; <span class="number">0</span> || cur_y &gt;= N) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[cur_x][cur_y] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[cur_x][cur_y]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        visited[cur_x][cur_y] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 정점에 도착했을 때</span></span><br><span class="line">        <span class="keyword">if</span> (m[cur_x][cur_y] == <span class="string">&#x27;S&#x27;</span> || m[cur_x][cur_y] == <span class="string">&#x27;K&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_w) &#123;</span><br><span class="line">                <span class="keyword">auto</span> m = v[&#123;cur_x, cur_y&#125;];</span><br><span class="line">                adj[n].<span class="built_in">push_back</span>(&#123;m, cur_w&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nxt_x = cur_x + dx[i];</span><br><span class="line">            <span class="type">int</span> nxt_y = cur_y + dy[i];</span><br><span class="line">            <span class="type">int</span> nxt_w = cur_w + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nxt_w, nxt_x, nxt_y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그래프가 완성이 되면 Prim 알고리즘을 통해 MST를 만들었다.</p><p>모든 열쇠를 찾는게 불가능 할 경우 -1을 반환해야 하므로 거리가 INF인 가중치가 있을 때는 -1을 반환해주고 그게 아니라면 가중치의 합을 모두 계산해 합을 반환해주었다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 만들어진 MST로 최소 이동 거리를 계산한다.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(M + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_w, cur_n] = pq.<span class="built_in">top</span>();</span><br><span class="line">        cur_w = -cur_w;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d[cur_n] != INF) <span class="keyword">continue</span>;</span><br><span class="line">        d[cur_n] = cur_w;</span><br><span class="line">        <span class="keyword">if</span> (++cnt == M + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt_n, nxt_w] : adj[cur_n]) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;-nxt_w, nxt_n&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : d) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 모든 열쇠를 찾을 수 없기 때문에 -1을 반환한다.</span></span><br><span class="line">        <span class="keyword">if</span> (i == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF (int) 1e9</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line">vector&lt;string&gt; m;</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; v;</span><br><span class="line">vector&lt;vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = v[&#123;sx, sy&#125;];</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visited</span>(N, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(N));</span><br><span class="line">    queue&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, sx, sy&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_w, cur_x, cur_y] = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_x &lt; <span class="number">0</span> || cur_x &gt;= N || cur_y &lt; <span class="number">0</span> || cur_y &gt;= N) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[cur_x][cur_y] == <span class="string">&#x27;1&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[cur_x][cur_y]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        visited[cur_x][cur_y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (m[cur_x][cur_y] == <span class="string">&#x27;S&#x27;</span> || m[cur_x][cur_y] == <span class="string">&#x27;K&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_w) &#123;</span><br><span class="line">                <span class="keyword">auto</span> m = v[&#123;cur_x, cur_y&#125;];</span><br><span class="line">                adj[n].<span class="built_in">push_back</span>(&#123;m, cur_w&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> nxt_x = cur_x + dx[i];</span><br><span class="line">            <span class="type">int</span> nxt_y = cur_y + dy[i];</span><br><span class="line">            <span class="type">int</span> nxt_w = cur_w + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(&#123;nxt_w, nxt_x, nxt_y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(M + <span class="number">1</span>, INF)</span></span>;</span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cur_w, cur_n] = pq.<span class="built_in">top</span>();</span><br><span class="line">        cur_w = -cur_w;</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (d[cur_n] != INF) <span class="keyword">continue</span>;</span><br><span class="line">        d[cur_n] = cur_w;</span><br><span class="line">        <span class="keyword">if</span> (++cnt == M + <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [nxt_n, nxt_w] : adj[cur_n]) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;-nxt_w, nxt_n&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    m.<span class="built_in">assign</span>(N, <span class="built_in">string</span>());</span><br><span class="line">    <span class="type">int</span> vc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        cin &gt;&gt; m[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i][j] == <span class="string">&#x27;S&#x27;</span>) v.<span class="built_in">insert</span>(&#123;&#123;i, j&#125;, <span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[i][j] == <span class="string">&#x27;K&#x27;</span>) v.<span class="built_in">insert</span>(&#123;&#123;i, j&#125;, vc++&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    adj.<span class="built_in">assign</span>(M + <span class="number">1</span>, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">        <span class="built_in">BFS</span>(i.first.first, i.first.second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Prim</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/1944/1.png"><br>미로의 크기 $N$의 범위가 $(4 \leq N \leq 50)$ 열쇠의 개수 $M$의 범위가 $(1 \leq M \leq 250)$이기 때문에 각 정점에 대해 모두 BFS를 돌더라도 시간이 여유로워 나이브하게 구현한 문제였다.</p><p>주어진 문제를 그래프를 변환하는 것이 번거롭긴 하지만 변환만 된다면 쉽게 풀 수 있는 문제라 생각한다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Graph-Traversal/">Graph Traversal</category>
      
      <category domain="https://ch2mi.github.io/tags/BFS/">BFS</category>
      
      <category domain="https://ch2mi.github.io/tags/MST/">MST</category>
      
      
      <comments>https://ch2mi.github.io/2024/10/28/1944/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 7894 큰 수 (C++)</title>
      <link>https://ch2mi.github.io/2024/10/27/7894/</link>
      <guid>https://ch2mi.github.io/2024/10/27/7894/</guid>
      <pubDate>Sun, 27 Oct 2024 08:04:14 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS83ODk0&quot;&gt;https://www.acmicpc.net/problem/7894&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;많은 어플리케이션은 매우 큰 수를 사용한다. 이러한 어플리케이션은 데이터를 안전하게 전송하고, 암호화하기 위해서 수를 키로 사용한다.&lt;/p&gt;
&lt;p&gt;수가 주어지면, 그 수의 팩토리얼의 자리수를 구하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS83ODk0">https://www.acmicpc.net/problem/7894<i class="fa fa-external-link-alt"></i></span></p><p>많은 어플리케이션은 매우 큰 수를 사용한다. 이러한 어플리케이션은 데이터를 안전하게 전송하고, 암호화하기 위해서 수를 키로 사용한다.</p><p>수가 주어지면, 그 수의 팩토리얼의 자리수를 구하는 프로그램을 작성하시오.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>주어진 정수 $m$의 범위가 $(1 \leq m \leq 10^7)$ 이므로 그대로 $m!$을 구하기엔 무리가 있다.</p><p>그래서 사용한 것이 로그이다. </p><p>$\log(a)$는 $a$를 만들기 위한 10의 지수 값을 물어보는 것인데, 이때 지수 값은 곧 자리수와 연관이 있다.</p><p>100으로 예를 들어보면 $\log(100) &#x3D; 2$이고 100의 자리수는 총 3자리이다. </p><p>또한 954도 계산해보면 $\log(954) &#x3D; 2.9795…$이고 954의 자리수는 총 3자리이다.</p><p>즉 계산한 결과에 로그를 취해서 소수점을 절사한다음 1을 더해주면 자리수가 나오는 것이다.</p><p>$$m! &#x3D; m * (m - 1) * (m - 2) * … * 2 * 1$$</p><p>위 식에 로그를 취하면 로그의 성질에 의해 곱셈이 덧셈으로 분리된다. 따라서 아래와 같은 식으로 변한다.</p><p>$$\log(m!) &#x3D; \log(m) + \log(m - 1) + \log(m - 2) + … + log(2) + log(1)$$</p><p>자리수는 1~m까지의 각각의 로그값의 합의 소숫점을 절사한 뒤 1을 더해주면 얻을 수 있다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> N; cin &gt;&gt; N;</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            count += <span class="built_in">log10</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; (<span class="type">int</span>)count &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/7894/1.png"><br>오차때매 틀릴 것 같아서 걱정했었는데 다행히 AC를 받을 수 있었다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Math/">Math</category>
      
      
      <comments>https://ch2mi.github.io/2024/10/27/7894/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[백준] 3273 두 수의 합 (C++)</title>
      <link>https://ch2mi.github.io/2024/10/19/3273/</link>
      <guid>https://ch2mi.github.io/2024/10/19/3273/</guid>
      <pubDate>Sat, 19 Oct 2024 09:12:20 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;문제&quot;&gt;&lt;a href=&quot;#문제&quot; class=&quot;headerlink&quot; title=&quot;문제&quot;&gt;&lt;/a&gt;문제&lt;/h3&gt;&lt;p&gt;원문 링크 : &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8zMjcz&quot;&gt;https://www.acmicpc.net/problem/3273&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;n개의 서로 다른 양의 정수 $a_1, a_2, …, a_n$으로 이루어진 수열이 있다. $a_i$의 값은 1보다 크거나 같고, 1000000보다 작거나 같은 자연수이다. 자연수 $x$가 주어졌을 때, $a_i + a_j &amp;#x3D; x$ $(1 ≤ i &amp;lt; j ≤ n)$을 만족하는 $(a_i, a_j)$쌍의 수를 구하는 프로그램을 작성하시오.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h3><p>원문 링크 : <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWNtaWNwYy5uZXQvcHJvYmxlbS8zMjcz">https://www.acmicpc.net/problem/3273<i class="fa fa-external-link-alt"></i></span></p><p>n개의 서로 다른 양의 정수 $a_1, a_2, …, a_n$으로 이루어진 수열이 있다. $a_i$의 값은 1보다 크거나 같고, 1000000보다 작거나 같은 자연수이다. 자연수 $x$가 주어졌을 때, $a_i + a_j &#x3D; x$ $(1 ≤ i &lt; j ≤ n)$을 만족하는 $(a_i, a_j)$쌍의 수를 구하는 프로그램을 작성하시오.</p><span id="more"></span><h3 id="풀이-및-구현"><a href="#풀이-및-구현" class="headerlink" title="풀이 및 구현"></a>풀이 및 구현</h3><p>문제를 풀기 위해 투 포인터 알고리즘을 사용했다.</p><p>문제에서 주어진 수열을 우선 오름차순으로 정렬한다.<br>$$5, 12, 7, 10, 9, 1, 2, 3, 11 \rightarrow 1, 2, 3, 5, 7, 9, 10, 11, 12$$<br>수열의 왼쪽 끝을 가르키는 $l$과 수열의 오른쪽 끝을 가르키는 $r$을 만든다.</p><p>두 인덱스가 가르키는 원소를 더했을 때 나올 수 있는 경우의 수는 아래와 같다.</p><p>$$1. v[l] + v[r] &lt; x$$<br>$$2. v[l] + v[r] &gt; x$$<br>$$3. v[l] + v[r] &#x3D; x$$</p><p>1번은 현재 목표 값보다 합이 작기 때문에 $l$포인터를 증가시켜 합을 크게 만든다.</p><p>2번은 현재 목표 값보다 합이 크기 때문에 $r$포인터를 감소시켜 합을 작게 만든다.</p><p>3번일 때 현재 목표 값과 동일하므로 $(a_i, a_j)$에 추가한다.<br>이 때 수열의 값은 모두 다르기 때문에 $v[l]$과 $v[r]$ 둘 중 하나를 이용해서 새롭게 $x$를 만들어 낼 수 없다.<br>그러므로 $l$포인터는 증가시키고 $r$포인터는 감소시켜 새로운 순서쌍을 찾을 수 있게 한다.</p><p>위 과정을 $l$포인터가 $r$포인터보다 작을 때까지 반복하면서 순서쌍의 개수를 세주면 문제를 해결할 수 있다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a>코드</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  </span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); cout.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);  </span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> n, x;  </span><br><span class="line">    cin &gt;&gt; n;  </span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : v) cin &gt;&gt; i;  </span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());  </span><br><span class="line">    cin &gt;&gt; x;  </span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, cnt = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;  </span><br><span class="line">        <span class="type">int</span> sum = v[l] + v[r];  </span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= x) l++;  </span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= x) r--;  </span><br><span class="line">        <span class="keyword">if</span> (sum == x) cnt++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; cnt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="후기"><a href="#후기" class="headerlink" title="후기"></a>후기</h3><p><img src="/image/3273/1.png"><br>바로 먼저 투 포인터가 생각나서 투 포인터로 풀었다.<br>이외에도 이분 탐색을 사용해서 풀 수도 있을 것이고<br>$a_i$의 범위가 $1\leq a_i \leq 1000000$이므로 $a_i$에 대해 $x-a_i$가 존재하는지 찾아본다면<br>정렬이 필요하지 않으므로 $O(n)$으로도 풀 수 있을 것이다.</p>]]></content:encoded>
      
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://ch2mi.github.io/categories/Algorithm/%EB%B0%B1%EC%A4%80/">백준</category>
      
      
      <category domain="https://ch2mi.github.io/tags/Sorting/">Sorting</category>
      
      <category domain="https://ch2mi.github.io/tags/Two-pointer/">Two-pointer</category>
      
      
      <comments>https://ch2mi.github.io/2024/10/19/3273/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
